package messages

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/go/classroom-4/teachers/homework/internal/model/messages.UserDB -o ./user_db_mock_test.go -n UserDBMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UserDBMock implements UserDB
type UserDBMock struct {
	t minimock.Tester

	funcChangeDefaultCurrency          func(ctx context.Context, userID int64, currency string) (err error)
	inspectFuncChangeDefaultCurrency   func(ctx context.Context, userID int64, currency string)
	afterChangeDefaultCurrencyCounter  uint64
	beforeChangeDefaultCurrencyCounter uint64
	ChangeDefaultCurrencyMock          mUserDBMockChangeDefaultCurrency

	funcGetDefaultCurrency          func(ctx context.Context, userID int64) (s1 string, err error)
	inspectFuncGetDefaultCurrency   func(ctx context.Context, userID int64)
	afterGetDefaultCurrencyCounter  uint64
	beforeGetDefaultCurrencyCounter uint64
	GetDefaultCurrencyMock          mUserDBMockGetDefaultCurrency

	funcUserExist          func(ctx context.Context, userID int64) (b1 bool)
	inspectFuncUserExist   func(ctx context.Context, userID int64)
	afterUserExistCounter  uint64
	beforeUserExistCounter uint64
	UserExistMock          mUserDBMockUserExist
}

// NewUserDBMock returns a mock for UserDB
func NewUserDBMock(t minimock.Tester) *UserDBMock {
	m := &UserDBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChangeDefaultCurrencyMock = mUserDBMockChangeDefaultCurrency{mock: m}
	m.ChangeDefaultCurrencyMock.callArgs = []*UserDBMockChangeDefaultCurrencyParams{}

	m.GetDefaultCurrencyMock = mUserDBMockGetDefaultCurrency{mock: m}
	m.GetDefaultCurrencyMock.callArgs = []*UserDBMockGetDefaultCurrencyParams{}

	m.UserExistMock = mUserDBMockUserExist{mock: m}
	m.UserExistMock.callArgs = []*UserDBMockUserExistParams{}

	return m
}

type mUserDBMockChangeDefaultCurrency struct {
	mock               *UserDBMock
	defaultExpectation *UserDBMockChangeDefaultCurrencyExpectation
	expectations       []*UserDBMockChangeDefaultCurrencyExpectation

	callArgs []*UserDBMockChangeDefaultCurrencyParams
	mutex    sync.RWMutex
}

// UserDBMockChangeDefaultCurrencyExpectation specifies expectation struct of the UserDB.ChangeDefaultCurrency
type UserDBMockChangeDefaultCurrencyExpectation struct {
	mock    *UserDBMock
	params  *UserDBMockChangeDefaultCurrencyParams
	results *UserDBMockChangeDefaultCurrencyResults
	Counter uint64
}

// UserDBMockChangeDefaultCurrencyParams contains parameters of the UserDB.ChangeDefaultCurrency
type UserDBMockChangeDefaultCurrencyParams struct {
	ctx      context.Context
	userID   int64
	currency string
}

// UserDBMockChangeDefaultCurrencyResults contains results of the UserDB.ChangeDefaultCurrency
type UserDBMockChangeDefaultCurrencyResults struct {
	err error
}

// Expect sets up expected params for UserDB.ChangeDefaultCurrency
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) Expect(ctx context.Context, userID int64, currency string) *mUserDBMockChangeDefaultCurrency {
	if mmChangeDefaultCurrency.mock.funcChangeDefaultCurrency != nil {
		mmChangeDefaultCurrency.mock.t.Fatalf("UserDBMock.ChangeDefaultCurrency mock is already set by Set")
	}

	if mmChangeDefaultCurrency.defaultExpectation == nil {
		mmChangeDefaultCurrency.defaultExpectation = &UserDBMockChangeDefaultCurrencyExpectation{}
	}

	mmChangeDefaultCurrency.defaultExpectation.params = &UserDBMockChangeDefaultCurrencyParams{ctx, userID, currency}
	for _, e := range mmChangeDefaultCurrency.expectations {
		if minimock.Equal(e.params, mmChangeDefaultCurrency.defaultExpectation.params) {
			mmChangeDefaultCurrency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangeDefaultCurrency.defaultExpectation.params)
		}
	}

	return mmChangeDefaultCurrency
}

// Inspect accepts an inspector function that has same arguments as the UserDB.ChangeDefaultCurrency
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) Inspect(f func(ctx context.Context, userID int64, currency string)) *mUserDBMockChangeDefaultCurrency {
	if mmChangeDefaultCurrency.mock.inspectFuncChangeDefaultCurrency != nil {
		mmChangeDefaultCurrency.mock.t.Fatalf("Inspect function is already set for UserDBMock.ChangeDefaultCurrency")
	}

	mmChangeDefaultCurrency.mock.inspectFuncChangeDefaultCurrency = f

	return mmChangeDefaultCurrency
}

// Return sets up results that will be returned by UserDB.ChangeDefaultCurrency
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) Return(err error) *UserDBMock {
	if mmChangeDefaultCurrency.mock.funcChangeDefaultCurrency != nil {
		mmChangeDefaultCurrency.mock.t.Fatalf("UserDBMock.ChangeDefaultCurrency mock is already set by Set")
	}

	if mmChangeDefaultCurrency.defaultExpectation == nil {
		mmChangeDefaultCurrency.defaultExpectation = &UserDBMockChangeDefaultCurrencyExpectation{mock: mmChangeDefaultCurrency.mock}
	}
	mmChangeDefaultCurrency.defaultExpectation.results = &UserDBMockChangeDefaultCurrencyResults{err}
	return mmChangeDefaultCurrency.mock
}

//Set uses given function f to mock the UserDB.ChangeDefaultCurrency method
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) Set(f func(ctx context.Context, userID int64, currency string) (err error)) *UserDBMock {
	if mmChangeDefaultCurrency.defaultExpectation != nil {
		mmChangeDefaultCurrency.mock.t.Fatalf("Default expectation is already set for the UserDB.ChangeDefaultCurrency method")
	}

	if len(mmChangeDefaultCurrency.expectations) > 0 {
		mmChangeDefaultCurrency.mock.t.Fatalf("Some expectations are already set for the UserDB.ChangeDefaultCurrency method")
	}

	mmChangeDefaultCurrency.mock.funcChangeDefaultCurrency = f
	return mmChangeDefaultCurrency.mock
}

// When sets expectation for the UserDB.ChangeDefaultCurrency which will trigger the result defined by the following
// Then helper
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) When(ctx context.Context, userID int64, currency string) *UserDBMockChangeDefaultCurrencyExpectation {
	if mmChangeDefaultCurrency.mock.funcChangeDefaultCurrency != nil {
		mmChangeDefaultCurrency.mock.t.Fatalf("UserDBMock.ChangeDefaultCurrency mock is already set by Set")
	}

	expectation := &UserDBMockChangeDefaultCurrencyExpectation{
		mock:   mmChangeDefaultCurrency.mock,
		params: &UserDBMockChangeDefaultCurrencyParams{ctx, userID, currency},
	}
	mmChangeDefaultCurrency.expectations = append(mmChangeDefaultCurrency.expectations, expectation)
	return expectation
}

// Then sets up UserDB.ChangeDefaultCurrency return parameters for the expectation previously defined by the When method
func (e *UserDBMockChangeDefaultCurrencyExpectation) Then(err error) *UserDBMock {
	e.results = &UserDBMockChangeDefaultCurrencyResults{err}
	return e.mock
}

// ChangeDefaultCurrency implements UserDB
func (mmChangeDefaultCurrency *UserDBMock) ChangeDefaultCurrency(ctx context.Context, userID int64, currency string) (err error) {
	mm_atomic.AddUint64(&mmChangeDefaultCurrency.beforeChangeDefaultCurrencyCounter, 1)
	defer mm_atomic.AddUint64(&mmChangeDefaultCurrency.afterChangeDefaultCurrencyCounter, 1)

	if mmChangeDefaultCurrency.inspectFuncChangeDefaultCurrency != nil {
		mmChangeDefaultCurrency.inspectFuncChangeDefaultCurrency(ctx, userID, currency)
	}

	mm_params := &UserDBMockChangeDefaultCurrencyParams{ctx, userID, currency}

	// Record call args
	mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.mutex.Lock()
	mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.callArgs = append(mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.callArgs, mm_params)
	mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.mutex.Unlock()

	for _, e := range mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.defaultExpectation.Counter, 1)
		mm_want := mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.defaultExpectation.params
		mm_got := UserDBMockChangeDefaultCurrencyParams{ctx, userID, currency}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangeDefaultCurrency.t.Errorf("UserDBMock.ChangeDefaultCurrency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.defaultExpectation.results
		if mm_results == nil {
			mmChangeDefaultCurrency.t.Fatal("No results are set for the UserDBMock.ChangeDefaultCurrency")
		}
		return (*mm_results).err
	}
	if mmChangeDefaultCurrency.funcChangeDefaultCurrency != nil {
		return mmChangeDefaultCurrency.funcChangeDefaultCurrency(ctx, userID, currency)
	}
	mmChangeDefaultCurrency.t.Fatalf("Unexpected call to UserDBMock.ChangeDefaultCurrency. %v %v %v", ctx, userID, currency)
	return
}

// ChangeDefaultCurrencyAfterCounter returns a count of finished UserDBMock.ChangeDefaultCurrency invocations
func (mmChangeDefaultCurrency *UserDBMock) ChangeDefaultCurrencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeDefaultCurrency.afterChangeDefaultCurrencyCounter)
}

// ChangeDefaultCurrencyBeforeCounter returns a count of UserDBMock.ChangeDefaultCurrency invocations
func (mmChangeDefaultCurrency *UserDBMock) ChangeDefaultCurrencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeDefaultCurrency.beforeChangeDefaultCurrencyCounter)
}

// Calls returns a list of arguments used in each call to UserDBMock.ChangeDefaultCurrency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) Calls() []*UserDBMockChangeDefaultCurrencyParams {
	mmChangeDefaultCurrency.mutex.RLock()

	argCopy := make([]*UserDBMockChangeDefaultCurrencyParams, len(mmChangeDefaultCurrency.callArgs))
	copy(argCopy, mmChangeDefaultCurrency.callArgs)

	mmChangeDefaultCurrency.mutex.RUnlock()

	return argCopy
}

// MinimockChangeDefaultCurrencyDone returns true if the count of the ChangeDefaultCurrency invocations corresponds
// the number of defined expectations
func (m *UserDBMock) MinimockChangeDefaultCurrencyDone() bool {
	for _, e := range m.ChangeDefaultCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeDefaultCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChangeDefaultCurrencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeDefaultCurrency != nil && mm_atomic.LoadUint64(&m.afterChangeDefaultCurrencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockChangeDefaultCurrencyInspect logs each unmet expectation
func (m *UserDBMock) MinimockChangeDefaultCurrencyInspect() {
	for _, e := range m.ChangeDefaultCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBMock.ChangeDefaultCurrency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeDefaultCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChangeDefaultCurrencyCounter) < 1 {
		if m.ChangeDefaultCurrencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserDBMock.ChangeDefaultCurrency")
		} else {
			m.t.Errorf("Expected call to UserDBMock.ChangeDefaultCurrency with params: %#v", *m.ChangeDefaultCurrencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeDefaultCurrency != nil && mm_atomic.LoadUint64(&m.afterChangeDefaultCurrencyCounter) < 1 {
		m.t.Error("Expected call to UserDBMock.ChangeDefaultCurrency")
	}
}

type mUserDBMockGetDefaultCurrency struct {
	mock               *UserDBMock
	defaultExpectation *UserDBMockGetDefaultCurrencyExpectation
	expectations       []*UserDBMockGetDefaultCurrencyExpectation

	callArgs []*UserDBMockGetDefaultCurrencyParams
	mutex    sync.RWMutex
}

// UserDBMockGetDefaultCurrencyExpectation specifies expectation struct of the UserDB.GetDefaultCurrency
type UserDBMockGetDefaultCurrencyExpectation struct {
	mock    *UserDBMock
	params  *UserDBMockGetDefaultCurrencyParams
	results *UserDBMockGetDefaultCurrencyResults
	Counter uint64
}

// UserDBMockGetDefaultCurrencyParams contains parameters of the UserDB.GetDefaultCurrency
type UserDBMockGetDefaultCurrencyParams struct {
	ctx    context.Context
	userID int64
}

// UserDBMockGetDefaultCurrencyResults contains results of the UserDB.GetDefaultCurrency
type UserDBMockGetDefaultCurrencyResults struct {
	s1  string
	err error
}

// Expect sets up expected params for UserDB.GetDefaultCurrency
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) Expect(ctx context.Context, userID int64) *mUserDBMockGetDefaultCurrency {
	if mmGetDefaultCurrency.mock.funcGetDefaultCurrency != nil {
		mmGetDefaultCurrency.mock.t.Fatalf("UserDBMock.GetDefaultCurrency mock is already set by Set")
	}

	if mmGetDefaultCurrency.defaultExpectation == nil {
		mmGetDefaultCurrency.defaultExpectation = &UserDBMockGetDefaultCurrencyExpectation{}
	}

	mmGetDefaultCurrency.defaultExpectation.params = &UserDBMockGetDefaultCurrencyParams{ctx, userID}
	for _, e := range mmGetDefaultCurrency.expectations {
		if minimock.Equal(e.params, mmGetDefaultCurrency.defaultExpectation.params) {
			mmGetDefaultCurrency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDefaultCurrency.defaultExpectation.params)
		}
	}

	return mmGetDefaultCurrency
}

// Inspect accepts an inspector function that has same arguments as the UserDB.GetDefaultCurrency
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) Inspect(f func(ctx context.Context, userID int64)) *mUserDBMockGetDefaultCurrency {
	if mmGetDefaultCurrency.mock.inspectFuncGetDefaultCurrency != nil {
		mmGetDefaultCurrency.mock.t.Fatalf("Inspect function is already set for UserDBMock.GetDefaultCurrency")
	}

	mmGetDefaultCurrency.mock.inspectFuncGetDefaultCurrency = f

	return mmGetDefaultCurrency
}

// Return sets up results that will be returned by UserDB.GetDefaultCurrency
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) Return(s1 string, err error) *UserDBMock {
	if mmGetDefaultCurrency.mock.funcGetDefaultCurrency != nil {
		mmGetDefaultCurrency.mock.t.Fatalf("UserDBMock.GetDefaultCurrency mock is already set by Set")
	}

	if mmGetDefaultCurrency.defaultExpectation == nil {
		mmGetDefaultCurrency.defaultExpectation = &UserDBMockGetDefaultCurrencyExpectation{mock: mmGetDefaultCurrency.mock}
	}
	mmGetDefaultCurrency.defaultExpectation.results = &UserDBMockGetDefaultCurrencyResults{s1, err}
	return mmGetDefaultCurrency.mock
}

//Set uses given function f to mock the UserDB.GetDefaultCurrency method
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) Set(f func(ctx context.Context, userID int64) (s1 string, err error)) *UserDBMock {
	if mmGetDefaultCurrency.defaultExpectation != nil {
		mmGetDefaultCurrency.mock.t.Fatalf("Default expectation is already set for the UserDB.GetDefaultCurrency method")
	}

	if len(mmGetDefaultCurrency.expectations) > 0 {
		mmGetDefaultCurrency.mock.t.Fatalf("Some expectations are already set for the UserDB.GetDefaultCurrency method")
	}

	mmGetDefaultCurrency.mock.funcGetDefaultCurrency = f
	return mmGetDefaultCurrency.mock
}

// When sets expectation for the UserDB.GetDefaultCurrency which will trigger the result defined by the following
// Then helper
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) When(ctx context.Context, userID int64) *UserDBMockGetDefaultCurrencyExpectation {
	if mmGetDefaultCurrency.mock.funcGetDefaultCurrency != nil {
		mmGetDefaultCurrency.mock.t.Fatalf("UserDBMock.GetDefaultCurrency mock is already set by Set")
	}

	expectation := &UserDBMockGetDefaultCurrencyExpectation{
		mock:   mmGetDefaultCurrency.mock,
		params: &UserDBMockGetDefaultCurrencyParams{ctx, userID},
	}
	mmGetDefaultCurrency.expectations = append(mmGetDefaultCurrency.expectations, expectation)
	return expectation
}

// Then sets up UserDB.GetDefaultCurrency return parameters for the expectation previously defined by the When method
func (e *UserDBMockGetDefaultCurrencyExpectation) Then(s1 string, err error) *UserDBMock {
	e.results = &UserDBMockGetDefaultCurrencyResults{s1, err}
	return e.mock
}

// GetDefaultCurrency implements UserDB
func (mmGetDefaultCurrency *UserDBMock) GetDefaultCurrency(ctx context.Context, userID int64) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetDefaultCurrency.beforeGetDefaultCurrencyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDefaultCurrency.afterGetDefaultCurrencyCounter, 1)

	if mmGetDefaultCurrency.inspectFuncGetDefaultCurrency != nil {
		mmGetDefaultCurrency.inspectFuncGetDefaultCurrency(ctx, userID)
	}

	mm_params := &UserDBMockGetDefaultCurrencyParams{ctx, userID}

	// Record call args
	mmGetDefaultCurrency.GetDefaultCurrencyMock.mutex.Lock()
	mmGetDefaultCurrency.GetDefaultCurrencyMock.callArgs = append(mmGetDefaultCurrency.GetDefaultCurrencyMock.callArgs, mm_params)
	mmGetDefaultCurrency.GetDefaultCurrencyMock.mutex.Unlock()

	for _, e := range mmGetDefaultCurrency.GetDefaultCurrencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetDefaultCurrency.GetDefaultCurrencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDefaultCurrency.GetDefaultCurrencyMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDefaultCurrency.GetDefaultCurrencyMock.defaultExpectation.params
		mm_got := UserDBMockGetDefaultCurrencyParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDefaultCurrency.t.Errorf("UserDBMock.GetDefaultCurrency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDefaultCurrency.GetDefaultCurrencyMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDefaultCurrency.t.Fatal("No results are set for the UserDBMock.GetDefaultCurrency")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetDefaultCurrency.funcGetDefaultCurrency != nil {
		return mmGetDefaultCurrency.funcGetDefaultCurrency(ctx, userID)
	}
	mmGetDefaultCurrency.t.Fatalf("Unexpected call to UserDBMock.GetDefaultCurrency. %v %v", ctx, userID)
	return
}

// GetDefaultCurrencyAfterCounter returns a count of finished UserDBMock.GetDefaultCurrency invocations
func (mmGetDefaultCurrency *UserDBMock) GetDefaultCurrencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultCurrency.afterGetDefaultCurrencyCounter)
}

// GetDefaultCurrencyBeforeCounter returns a count of UserDBMock.GetDefaultCurrency invocations
func (mmGetDefaultCurrency *UserDBMock) GetDefaultCurrencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultCurrency.beforeGetDefaultCurrencyCounter)
}

// Calls returns a list of arguments used in each call to UserDBMock.GetDefaultCurrency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) Calls() []*UserDBMockGetDefaultCurrencyParams {
	mmGetDefaultCurrency.mutex.RLock()

	argCopy := make([]*UserDBMockGetDefaultCurrencyParams, len(mmGetDefaultCurrency.callArgs))
	copy(argCopy, mmGetDefaultCurrency.callArgs)

	mmGetDefaultCurrency.mutex.RUnlock()

	return argCopy
}

// MinimockGetDefaultCurrencyDone returns true if the count of the GetDefaultCurrency invocations corresponds
// the number of defined expectations
func (m *UserDBMock) MinimockGetDefaultCurrencyDone() bool {
	for _, e := range m.GetDefaultCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefaultCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDefaultCurrencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefaultCurrency != nil && mm_atomic.LoadUint64(&m.afterGetDefaultCurrencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDefaultCurrencyInspect logs each unmet expectation
func (m *UserDBMock) MinimockGetDefaultCurrencyInspect() {
	for _, e := range m.GetDefaultCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBMock.GetDefaultCurrency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefaultCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDefaultCurrencyCounter) < 1 {
		if m.GetDefaultCurrencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserDBMock.GetDefaultCurrency")
		} else {
			m.t.Errorf("Expected call to UserDBMock.GetDefaultCurrency with params: %#v", *m.GetDefaultCurrencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefaultCurrency != nil && mm_atomic.LoadUint64(&m.afterGetDefaultCurrencyCounter) < 1 {
		m.t.Error("Expected call to UserDBMock.GetDefaultCurrency")
	}
}

type mUserDBMockUserExist struct {
	mock               *UserDBMock
	defaultExpectation *UserDBMockUserExistExpectation
	expectations       []*UserDBMockUserExistExpectation

	callArgs []*UserDBMockUserExistParams
	mutex    sync.RWMutex
}

// UserDBMockUserExistExpectation specifies expectation struct of the UserDB.UserExist
type UserDBMockUserExistExpectation struct {
	mock    *UserDBMock
	params  *UserDBMockUserExistParams
	results *UserDBMockUserExistResults
	Counter uint64
}

// UserDBMockUserExistParams contains parameters of the UserDB.UserExist
type UserDBMockUserExistParams struct {
	ctx    context.Context
	userID int64
}

// UserDBMockUserExistResults contains results of the UserDB.UserExist
type UserDBMockUserExistResults struct {
	b1 bool
}

// Expect sets up expected params for UserDB.UserExist
func (mmUserExist *mUserDBMockUserExist) Expect(ctx context.Context, userID int64) *mUserDBMockUserExist {
	if mmUserExist.mock.funcUserExist != nil {
		mmUserExist.mock.t.Fatalf("UserDBMock.UserExist mock is already set by Set")
	}

	if mmUserExist.defaultExpectation == nil {
		mmUserExist.defaultExpectation = &UserDBMockUserExistExpectation{}
	}

	mmUserExist.defaultExpectation.params = &UserDBMockUserExistParams{ctx, userID}
	for _, e := range mmUserExist.expectations {
		if minimock.Equal(e.params, mmUserExist.defaultExpectation.params) {
			mmUserExist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserExist.defaultExpectation.params)
		}
	}

	return mmUserExist
}

// Inspect accepts an inspector function that has same arguments as the UserDB.UserExist
func (mmUserExist *mUserDBMockUserExist) Inspect(f func(ctx context.Context, userID int64)) *mUserDBMockUserExist {
	if mmUserExist.mock.inspectFuncUserExist != nil {
		mmUserExist.mock.t.Fatalf("Inspect function is already set for UserDBMock.UserExist")
	}

	mmUserExist.mock.inspectFuncUserExist = f

	return mmUserExist
}

// Return sets up results that will be returned by UserDB.UserExist
func (mmUserExist *mUserDBMockUserExist) Return(b1 bool) *UserDBMock {
	if mmUserExist.mock.funcUserExist != nil {
		mmUserExist.mock.t.Fatalf("UserDBMock.UserExist mock is already set by Set")
	}

	if mmUserExist.defaultExpectation == nil {
		mmUserExist.defaultExpectation = &UserDBMockUserExistExpectation{mock: mmUserExist.mock}
	}
	mmUserExist.defaultExpectation.results = &UserDBMockUserExistResults{b1}
	return mmUserExist.mock
}

//Set uses given function f to mock the UserDB.UserExist method
func (mmUserExist *mUserDBMockUserExist) Set(f func(ctx context.Context, userID int64) (b1 bool)) *UserDBMock {
	if mmUserExist.defaultExpectation != nil {
		mmUserExist.mock.t.Fatalf("Default expectation is already set for the UserDB.UserExist method")
	}

	if len(mmUserExist.expectations) > 0 {
		mmUserExist.mock.t.Fatalf("Some expectations are already set for the UserDB.UserExist method")
	}

	mmUserExist.mock.funcUserExist = f
	return mmUserExist.mock
}

// When sets expectation for the UserDB.UserExist which will trigger the result defined by the following
// Then helper
func (mmUserExist *mUserDBMockUserExist) When(ctx context.Context, userID int64) *UserDBMockUserExistExpectation {
	if mmUserExist.mock.funcUserExist != nil {
		mmUserExist.mock.t.Fatalf("UserDBMock.UserExist mock is already set by Set")
	}

	expectation := &UserDBMockUserExistExpectation{
		mock:   mmUserExist.mock,
		params: &UserDBMockUserExistParams{ctx, userID},
	}
	mmUserExist.expectations = append(mmUserExist.expectations, expectation)
	return expectation
}

// Then sets up UserDB.UserExist return parameters for the expectation previously defined by the When method
func (e *UserDBMockUserExistExpectation) Then(b1 bool) *UserDBMock {
	e.results = &UserDBMockUserExistResults{b1}
	return e.mock
}

// UserExist implements UserDB
func (mmUserExist *UserDBMock) UserExist(ctx context.Context, userID int64) (b1 bool) {
	mm_atomic.AddUint64(&mmUserExist.beforeUserExistCounter, 1)
	defer mm_atomic.AddUint64(&mmUserExist.afterUserExistCounter, 1)

	if mmUserExist.inspectFuncUserExist != nil {
		mmUserExist.inspectFuncUserExist(ctx, userID)
	}

	mm_params := &UserDBMockUserExistParams{ctx, userID}

	// Record call args
	mmUserExist.UserExistMock.mutex.Lock()
	mmUserExist.UserExistMock.callArgs = append(mmUserExist.UserExistMock.callArgs, mm_params)
	mmUserExist.UserExistMock.mutex.Unlock()

	for _, e := range mmUserExist.UserExistMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUserExist.UserExistMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserExist.UserExistMock.defaultExpectation.Counter, 1)
		mm_want := mmUserExist.UserExistMock.defaultExpectation.params
		mm_got := UserDBMockUserExistParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserExist.t.Errorf("UserDBMock.UserExist got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserExist.UserExistMock.defaultExpectation.results
		if mm_results == nil {
			mmUserExist.t.Fatal("No results are set for the UserDBMock.UserExist")
		}
		return (*mm_results).b1
	}
	if mmUserExist.funcUserExist != nil {
		return mmUserExist.funcUserExist(ctx, userID)
	}
	mmUserExist.t.Fatalf("Unexpected call to UserDBMock.UserExist. %v %v", ctx, userID)
	return
}

// UserExistAfterCounter returns a count of finished UserDBMock.UserExist invocations
func (mmUserExist *UserDBMock) UserExistAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserExist.afterUserExistCounter)
}

// UserExistBeforeCounter returns a count of UserDBMock.UserExist invocations
func (mmUserExist *UserDBMock) UserExistBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserExist.beforeUserExistCounter)
}

// Calls returns a list of arguments used in each call to UserDBMock.UserExist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserExist *mUserDBMockUserExist) Calls() []*UserDBMockUserExistParams {
	mmUserExist.mutex.RLock()

	argCopy := make([]*UserDBMockUserExistParams, len(mmUserExist.callArgs))
	copy(argCopy, mmUserExist.callArgs)

	mmUserExist.mutex.RUnlock()

	return argCopy
}

// MinimockUserExistDone returns true if the count of the UserExist invocations corresponds
// the number of defined expectations
func (m *UserDBMock) MinimockUserExistDone() bool {
	for _, e := range m.UserExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserExistMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserExistCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserExist != nil && mm_atomic.LoadUint64(&m.afterUserExistCounter) < 1 {
		return false
	}
	return true
}

// MinimockUserExistInspect logs each unmet expectation
func (m *UserDBMock) MinimockUserExistInspect() {
	for _, e := range m.UserExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBMock.UserExist with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserExistMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserExistCounter) < 1 {
		if m.UserExistMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserDBMock.UserExist")
		} else {
			m.t.Errorf("Expected call to UserDBMock.UserExist with params: %#v", *m.UserExistMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserExist != nil && mm_atomic.LoadUint64(&m.afterUserExistCounter) < 1 {
		m.t.Error("Expected call to UserDBMock.UserExist")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserDBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockChangeDefaultCurrencyInspect()

		m.MinimockGetDefaultCurrencyInspect()

		m.MinimockUserExistInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserDBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserDBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChangeDefaultCurrencyDone() &&
		m.MinimockGetDefaultCurrencyDone() &&
		m.MinimockUserExistDone()
}
