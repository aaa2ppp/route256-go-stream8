// === cart/cmd/app/main.go ===
package main

import (
	"os"
	"route256/cart/internal/app"
)

func main() {
	os.Exit(app.Run())
}

// === cart/internal/app/app.go ===
package app

import (
	"context"
	"log"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"route256/cart/internal/config"
	grpcClient "route256/cart/internal/grpc/client"
	httpClient "route256/cart/internal/http/client"
	"route256/cart/internal/http/handler"
	"route256/cart/internal/memstor"
	"route256/cart/internal/service"
	"route256/cart/pkg/http/middleware"
	"syscall"
)

func Run() int {
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("can't load config: %v", err)
	}

	setupDefaultLogger(cfg.Logger)

	// lomsClient := httpClient.NewOrder(cfg.HTTPLOMSClient)
	lomsClient, err := grpcClient.NewOrder(cfg.GRPCLOMSClient)
	if err != nil {
		log.Fatal(err)
	}

	cartService := service.NewCart(
		memstor.NewCart(),
		lomsClient,
		httpClient.NewProduct(cfg.HTTPProductClient),
	)

	mux := http.NewServeMux()
	mux.HandleFunc("GET /ping", pong)
	mux.Handle("POST /cart/item/add", handler.CartAddItem(cartService.Add))
	mux.Handle("POST /cart/item/delete", handler.CartDeleteItem(cartService.Delete))
	mux.Handle("POST /cart/list", handler.CartList(cartService.List))
	mux.Handle("POST /cart/clear", handler.CartClear(cartService.Clear))
	mux.Handle("POST /cart/checkout", handler.CartCheckout(cartService.Checkout))

	httpServer := &http.Server{
		Addr:         cfg.HTTPServer.Addr,
		Handler:      middleware.Logging(slog.Default(), mux),
		ReadTimeout:  cfg.HTTPServer.ReadTimeout,
		WriteTimeout: cfg.HTTPServer.WriteTimeout,
	}

	done := make(chan int)
	go func() {
		defer close(done)

		c := make(chan os.Signal, 1)
		signal.Notify(c, os.Interrupt, syscall.SIGTERM)
		sig := <-c

		slog.Info("shutdown by signal", "signal", sig)
		ctx, cancel := context.WithTimeout(context.Background(), cfg.HTTPServer.ShutdownTimeout)
		defer cancel()
		if err := httpServer.Shutdown(ctx); err != nil {
			slog.Error("can't shutdown http server", "error", err)
			done <- 1
		}
	}()

	slog.Info("http server startup", "addr", httpServer.Addr)
	if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		slog.Error("http server fail", "error", err)
		return 1
	}

	slog.Info("http server stopped")
	return <-done
}

func setupDefaultLogger(cfg *config.Logger) {
	var handler slog.Handler
	if cfg.PlainText {
		handler = slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: cfg.Level})
	} else {
		handler = slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{Level: cfg.Level})
	}
	slog.SetDefault(slog.New(handler).With("app", "cart"))
}

func pong(w http.ResponseWriter, h *http.Request) {
	if _, err := w.Write([]byte("pong")); err != nil {
		slog.Error("ping: can't write pong")
	}
}

// === cart/internal/config/config.go ===
package config

import (
	"log/slog"
	"time"
)

type Logger struct {
	Level     slog.Level
	PlainText bool
}

type HTTPServer struct {
	Addr            string
	ReadTimeout     time.Duration
	WriteTimeout    time.Duration
	ShutdownTimeout time.Duration
}

type HTTPProductClient struct {
	BaseURL        string
	GetEndpoint    string
	RequestTimeout time.Duration
}

type HTTPLOMSClient struct {
	BaseURL              string
	CreateOrderEndpoint  string
	GetStockInfoEndpoint string
	RequestTimeout       time.Duration
}

type GRPCLOMSClient struct {
	Addr string
}

type Config struct {
	Logger            *Logger
	HTTPServer        *HTTPServer
	HTTPLOMSClient    *HTTPLOMSClient
	HTTPProductClient *HTTPProductClient
	GRPCLOMSClient    *GRPCLOMSClient
}

func Load() (Config, error) {
	return Config{
		Logger: &Logger{
			Level:     slog.LevelDebug,
			PlainText: true,
		},
		HTTPServer: &HTTPServer{
			Addr:            ":8080",
			ReadTimeout:     10 * time.Second,
			WriteTimeout:    10 * time.Second,
			ShutdownTimeout: 30 * time.Second,
		},
		HTTPLOMSClient: &HTTPLOMSClient{
			BaseURL:              "http://loms:8080",
			CreateOrderEndpoint:  "/order/create",
			GetStockInfoEndpoint: "/stock/info",
			RequestTimeout:       10 * time.Second,
		},
		HTTPProductClient: &HTTPProductClient{
			BaseURL:        "http://route256.pavl.uk:8080",
			GetEndpoint:    "/get_product",
			RequestTimeout: 10 * time.Second,
		},
		GRPCLOMSClient: &GRPCLOMSClient{
			Addr: "loms:50051",
		},
	}, nil
}

// === cart/internal/grpc/client/maperr.go ===
package client

import (
	"context"
	"route256/cart/internal/model"
	"route256/cart/pkg/http/middleware"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func mapError(ctx context.Context, err error) error {
	st, ok := status.FromError(err)
	if !ok {
		log := middleware.GetLoggerFromContextOrDefault(ctx)
		log.Warn("non-gRPC error detected", "error", err)
		return model.ErrInternalError
	}
	switch st.Code() {
	case codes.NotFound:
		return model.ErrNotFound
	case codes.FailedPrecondition:
		return model.ErrPreconditionFailed
	case codes.Internal:
		return model.ErrInternalError
	}
	log := middleware.GetLoggerFromContextOrDefault(ctx)
	log.Warn("unexpected status code", "code", st.Code())
	return model.ErrInternalError
}

// === cart/internal/grpc/client/order.go ===
package client

import (
	"context"
	"fmt"
	"route256/cart/internal/config"
	"route256/cart/internal/model"
	"route256/cart/internal/service"
	"route256/loms/pkg/api/order/v1"
	"route256/loms/pkg/api/stock/v1"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type Order struct {
	order order.OrderClient
	stock stock.StockClient
}

// CreateOrder implements service.OrderStorage.
func (o *Order) CreateOrder(ctx context.Context, req model.OrderCreateRequest) (model.OrderID, error) {
	creq := &order.CreateRequest{
		User:  int64(req.UserID),
		Items: make([]*order.Item, 0, len(req.Items)),
	}
	for _, item := range req.Items {
		creq.Items = append(creq.Items, &order.Item{
			Sku:   int32(item.SKU),
			Count: uint32(item.Count),
		})
	}
	cresp, err := o.order.Create(ctx, creq)
	if err != nil {
		return 0, mapError(ctx, err)
	}
	return model.OrderID(cresp.OrderID), nil
}

// GetStockInfo implements service.OrderStorage.
func (o *Order) GetStockInfo(ctx context.Context, sku model.SKU) (count uint64, _ error) {
	cresp, err := o.stock.GetInfo(ctx, &stock.GetInfoRequest{Sku: int32(sku)})
	if err != nil {
		return 0, mapError(ctx, err)
	}
	return cresp.Count, nil
}

func NewOrder(cfg *config.GRPCLOMSClient) (*Order, error) {
	conn, err := grpc.NewClient(cfg.Addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return nil, fmt.Errorf("can't create grpc client connection: %w", err)
	}
	order := order.NewOrderClient(conn)
	stock := stock.NewStockClient(conn)
	return &Order{
		order: order,
		stock: stock,
	}, nil
}

var _ service.OrderStorage = &Order{}

// === cart/internal/http/client/client.go ===
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

// client HTTP клиент для взаимодействия с API
type client struct {
	baseURL string
	client  *http.Client
}

// newClient создает новый экземпляр клиента
func newClient(baseURL string, requestTimeout time.Duration) client {
	return client{
		baseURL: baseURL,
		client: &http.Client{
			Timeout: requestTimeout,
		},
	}
}

// doRequest выполняет POST запрос и обрабатывает ответ
func (c client) doRequest(ctx context.Context, endpoint string, req, resp any) (status int, _ error) {

	// Подготовка тела запроса
	reqBody, err := json.Marshal(req)
	if err != nil {
		return 0, fmt.Errorf("marshal request: %w", err)
	}

	// Создание запроса
	httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.baseURL+endpoint, bytes.NewReader(reqBody))
	if err != nil {
		return 0, fmt.Errorf("create request: %w", err)
	}
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("Accept", "application/json")

	// Выполнение запроса
	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return 0, fmt.Errorf("execute request: %w", err)
	}
	defer httpResp.Body.Close()

	status = httpResp.StatusCode

	// Чтение ответа
	respBody, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return status, fmt.Errorf("read body failed: %w", err)
	}

	// Декодирование ответа
	if status == 200 || status == 201 {
		if err := json.Unmarshal(respBody, resp); err != nil {
			return status, fmt.Errorf("unmarshal response: %w", err)
		}
	}

	return status, nil
}

// === cart/internal/http/client/logger.go ===
package client

import (
	"context"
	"log/slog"
	"route256/cart/pkg/http/middleware"
)

func getLogger(ctx context.Context, op string) *slog.Logger {
	return middleware.GetLoggerFromContextOrDefault(ctx).
		With("op", "client#"+op)
}

// === cart/internal/http/client/order.go ===
package client

import (
	"context"
	"net/http"
	"route256/cart/internal/config"
	"route256/cart/internal/model"
	"route256/cart/internal/service"
)

type Order struct {
	client
	cfg *config.HTTPLOMSClient
}

func NewOrder(cfg *config.HTTPLOMSClient) Order {
	return Order{
		client: newClient(cfg.BaseURL, cfg.RequestTimeout),
		cfg:    cfg,
	}
}

type createOrderItem struct {
	SKU   model.SKU `json:"sku"`
	Count uint16    `json:"count"`
}

type createOrderRequest struct {
	User  model.UserID      `json:"user"`
	Items []createOrderItem `json:"items"`
}

type createOrderResponse struct {
	OrderID model.OrderID `json:"orderID"`
}

func (c Order) CreateOrder(ctx context.Context, req model.OrderCreateRequest) (resp model.OrderID, _ error) {
	log := getLogger(ctx, "Order.CreateOrder")

	creq := createOrderRequest{
		User:  req.UserID,
		Items: make([]createOrderItem, 0, len(req.Items)),
	}
	for _, item := range req.Items {
		creq.Items = append(creq.Items, createOrderItem{
			SKU:   item.SKU,
			Count: item.Count,
		})
	}

	var cresp createOrderResponse
	status, err := c.doRequest(ctx, c.cfg.CreateOrderEndpoint, &creq, &cresp)
	if err != nil {
		log.Error("can't do request", "error", err)
		return resp, model.ErrInternalError
	}

	switch status {
	case http.StatusOK, http.StatusCreated:
		return cresp.OrderID, nil
	case http.StatusPreconditionFailed:
		return resp, model.ErrPreconditionFailed
	}

	log.Error("unknown response status", "status", status)
	return resp, model.ErrInternalError
}

type getStockInfoRequest struct {
	SKU model.SKU `json:"sku"`
}

type getStockInfoResponse struct {
	Count uint64 `json:"count"`
}

func (c Order) GetStockInfo(ctx context.Context, sku model.SKU) (count uint64, _ error) {
	log := getLogger(ctx, "Order.GetStockInfo")

	creq := getStockInfoRequest{
		SKU: sku,
	}

	var cresp getStockInfoResponse
	status, err := c.doRequest(ctx, c.cfg.GetStockInfoEndpoint, &creq, &cresp)
	if err != nil {
		log.Error("can't do request", "error", err)
		return count, model.ErrInternalError
	}

	switch status {
	case http.StatusOK:
		return cresp.Count, nil
	case http.StatusNotFound:
		return count, model.ErrNotFound
	}

	log.Error("unknown response status", "status", status)
	return count, model.ErrInternalError
}

var _ service.OrderStorage = &Order{}

// === cart/internal/http/client/product.go ===
package client

import (
	"context"
	"net/http"
	"route256/cart/internal/config"
	"route256/cart/internal/model"
	"route256/cart/internal/service"
)

type Product struct {
	client
	cfg *config.HTTPProductClient
}

func NewProduct(cfg *config.HTTPProductClient) Product {
	return Product{
		client: newClient(cfg.BaseURL, cfg.RequestTimeout),
		cfg:    cfg,
	}
}

type productGetInfoRequest struct {
	Token string    `json:"token"`
	SKU   model.SKU `json:"sku"`
}

type productGetInfoResponse struct {
	Name  string `json:"name"`
	Price uint32 `json:"price"`
}

func (c Product) GetInfo(ctx context.Context, req model.GetProductRequest) (resp model.GetProductResponse, _ error) {
	log := getLogger(ctx, "Product.GetInfo")

	creq := productGetInfoRequest{
		Token: req.Token,
		SKU:   req.SKU,
	}

	var cresp productGetInfoResponse
	status, err := c.doRequest(ctx, c.cfg.GetEndpoint, &creq, &cresp)
	if err != nil {
		log.Error("can't do request", "error", err)
		return resp, model.ErrInternalError
	}

	switch status {
	case http.StatusOK:
		return model.GetProductResponse{
			Name:  cresp.Name,
			Price: cresp.Price,
		}, nil
	case http.StatusUnauthorized:
		return resp, model.ErrUnauthorized
	case http.StatusNotFound:
		return resp, model.ErrNotFound
	}

	log.Error("unknown response status", "status", status)
	return resp, model.ErrInternalError
}

var _ service.ProductStorage = &Product{}

// === cart/internal/http/handler/cart.go ===
package handler

import (
	"context"
	"errors"
	"net/http"
	"route256/cart/internal/model"
)

type cartAddItemRequest struct {
	User  model.UserID `json:"user"`
	SKU   model.SKU    `json:"sku"`
	Count uint16       `json:"count"`
}

func (req cartAddItemRequest) Validate() error {
	var errs []error
	if req.User <= 0 {
		errs = append(errs, errors.New("user must be > 0"))
	}
	if req.SKU <= 0 {
		errs = append(errs, errors.New("sku must be > 0"))
	}
	return errors.Join(errs...)
}

func CartAddItem(addFunc func(ctx context.Context, req model.AddCartItemRequest) error) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		x := newHelper(w, r, "CartAddItem")

		if !x.checkPOSTMethod() {
			return
		}

		token := x.getAuthToken()
		if token == "" {
			x.writeError(errUnauthorized)
			return
		}

		var req cartAddItemRequest
		if !x.decodeBodyAndValidateRequest(&req) {
			return
		}

		if err := addFunc(x.ctx(), model.AddCartItemRequest{
			Token:  token,
			UserID: req.User,
			Items:  []model.CartItem{{SKU: req.SKU, Count: req.Count}},
		}); err != nil {
			x.writeError(err)
			return
		}

		x.writeResponse(http.StatusOK, struct{}{})
	}
}

type cartDeleteItemRequest struct {
	User model.UserID `json:"user"`
	SKU  model.SKU    `json:"sku"`
}

func (req cartDeleteItemRequest) Validate() error {
	var errs []error
	if req.User <= 0 {
		errs = append(errs, errors.New("user must be > 0"))
	}
	if req.SKU <= 0 {
		errs = append(errs, errors.New("sku must be > 0"))
	}
	return errors.Join(errs...)
}

func CartDeleteItem(deleteFunc func(ctx context.Context, req model.DeleteCartItemRequest) error) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		x := newHelper(w, r, "CartDeleteItem")

		if !x.checkPOSTMethod() {
			return
		}

		var req cartDeleteItemRequest
		if !x.decodeBodyAndValidateRequest(&req) {
			return
		}

		if err := deleteFunc(x.ctx(), model.DeleteCartItemRequest{
			UserID: req.User,
			SKU:    req.SKU,
		}); err != nil {
			x.writeError(err)
			return
		}

		x.writeResponse(http.StatusOK, struct{}{})
	}
}

type userCartRequest struct {
	User model.UserID `json:"user"`
}

func (req userCartRequest) Validate() error {
	if req.User <= 0 {
		return errors.New("user must be > 0")
	}
	return nil
}

type cartList = userCartRequest

type cartListItem struct {
	SKU   model.SKU `json:"sku"`
	Count uint16    `json:"count"`
	Name  string    `json:"name"`
	Price uint32    `json:"price"`
}

type cartListResponse struct {
	Items      []cartListItem `json:"items"`
	TotalPrice uint32         `json:"totalPrice"`
}

func CartList(listFunc func(ctx context.Context, req model.CartListRequest) (model.CartListResponse, error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		x := newHelper(w, r, "CartList")

		if !x.checkPOSTMethod() {
			return
		}

		token := x.getAuthToken()
		if token == "" {
			x.writeError(errUnauthorized)
			return
		}

		var req cartList
		if !x.decodeBodyAndValidateRequest(&req) {
			return
		}

		cart, err := listFunc(x.ctx(), model.CartListRequest{
			Token:  token,
			UserID: req.User,
		})
		if err != nil {
			x.writeError(err)
			return
		}

		resp := cartListResponse{
			Items:      make([]cartListItem, 0, len(cart.Items)),
			TotalPrice: 0,
		}
		for _, item := range cart.Items {
			resp.Items = append(resp.Items, cartListItem{
				SKU:   item.SKU,
				Count: item.Count,
				Name:  item.Name,
				Price: item.Price,
			})
		}
		resp.TotalPrice = cart.TotalPrice

		x.writeResponse(http.StatusOK, resp)
	}
}

type cartClearRequest = userCartRequest

func CartClear(clearFunc func(ctx context.Context, userID model.UserID) error) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		x := newHelper(w, r, "CartClear")

		if !x.checkPOSTMethod() {
			return
		}

		var req cartClearRequest
		if !x.decodeBodyAndValidateRequest(&req) {
			return
		}

		if err := clearFunc(x.ctx(), req.User); err != nil {
			x.writeError(err)
			return
		}

		x.writeResponse(http.StatusOK, struct{}{})
	}
}

type cartCheckoutRequest = userCartRequest

type cartCheckoutResponse struct {
	OrderID model.OrderID `json:"orderID"`
}

func CartCheckout(checkoutFunc func(ctx context.Context, userID model.UserID) (model.OrderID, error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		x := newHelper(w, r, "CartCheckout")

		if !x.checkPOSTMethod() {
			return
		}

		var req cartCheckoutRequest
		if !x.decodeBodyAndValidateRequest(&req) {
			return
		}

		orderID, err := checkoutFunc(x.ctx(), req.User)
		if err != nil {
			x.writeError(err)
			return
		}

		x.writeResponse(http.StatusOK, cartCheckoutResponse{
			OrderID: orderID,
		})
	}
}

// === cart/internal/http/handler/error.go ===
package handler

import "fmt"

type httpError struct {
	Code    int
	Message string
}

func (e *httpError) Error() string {
	return fmt.Sprintf("%d: %s", e.Code, e.Message)
}

var (
	errInternalError      = &httpError{500, "internal error"}
	errBadRequest         = &httpError{400, "bad request"}
	errUnauthorized       = &httpError{401, "unauthorized"}
	errNotFound           = &httpError{404, "not found"}
	errPreconditionFailed = &httpError{412, "precondition failed"}
)

// === cart/internal/http/handler/helper.go ===
package handler

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"log/slog"
	"net/http"
	"reflect"
	"route256/cart/internal/model"
	"route256/cart/pkg/http/middleware"
)

type helper struct {
	w  http.ResponseWriter
	r  *http.Request
	lg *slog.Logger
}

func newHelper(w http.ResponseWriter, r *http.Request, op string) helper {
	return helper{
		w: w,
		r: r,
		lg: middleware.GetLoggerFromContextOrDefault(r.Context()).
			With("op", "handler#"+op),
	}
}

func (x helper) ctx() context.Context {
	return x.r.Context()
}

func (x helper) log() *slog.Logger {
	return x.lg
}

func (x helper) checkPOSTMethod() bool {
	if x.r.Method != http.MethodPost {
		x.log().Error("logical error: using for a non-POST request", "method", x.r.Method, "url", x.r.URL)
		x.writeError(errInternalError)
		return false
	}
	return true
}

func (x helper) getAuthToken() string {
	return x.r.Header.Get("X-Authtoken")
}

func (x helper) ReadBody() ([]byte, bool) {
	body, err := io.ReadAll(x.r.Body)
	if err != nil {
		x.log().Error("can't read request body", "error", err)
		x.writeError(errInternalError)
		return nil, false
	}
	return body, true
}

func (x helper) decodeBody(req any) bool {
	body, ok := x.ReadBody()
	if !ok {
		return false
	}
	if err := json.Unmarshal(body, req); err != nil {
		x.log().Debug("can't unmarshal request body", "error", err)
		x.writeError(errBadRequest)
		return false
	}
	return true
}

type Validator interface {
	Validate() error
}

func (x helper) validateRequest(req any) bool {
	if req2, ok := req.(Validator); !ok {
		x.log().Error("request not implement Validator", "reqType", reflect.TypeOf(req))
		x.writeError(errInternalError)
		return false
	} else if err := req2.Validate(); err != nil {
		x.log().Debug("can't validate request", "error", err)
		x.writeError(errBadRequest)
		return false
	}
	return true
}

func (x helper) decodeBodyAndValidateRequest(req any) bool {
	return x.decodeBody(req) && x.validateRequest(req)
}

func (x helper) writeResponse(status int, resp any) {
	jsonData, err := json.Marshal(resp)
	if err != nil {
		x.log().Error("can't marshal response", "error", err)
		x.writeError(errInternalError)
		return
	}

	x.w.Header().Add("content-type", "application/json")
	x.w.WriteHeader(status)

	if _, err := x.w.Write(jsonData); err != nil {
		x.log().Error("can't write response", "error", err)
		return
	}
}

func (x helper) writeError(err error) {
	var httpErr *httpError
	switch {
	case errors.As(err, &httpErr):
	case errors.Is(err, model.ErrUnauthorized):
		httpErr = errUnauthorized
	case errors.Is(err, model.ErrNotFound):
		httpErr = errNotFound
	case errors.Is(err, model.ErrPreconditionFailed):
		httpErr = errPreconditionFailed
	case errors.Is(err, model.ErrInternalError):
		httpErr = errInternalError
	default:
		x.log().Warn("unhandled error", "error", err)
		httpErr = errInternalError
	}
	http.Error(x.w, httpErr.Message, httpErr.Code)
}

// === cart/internal/memstor/cart.go ===
package memstor

import (
	"context"
	"route256/cart/internal/model"
	"route256/cart/internal/service"
	"slices"
	"sync"
)

type Cart struct {
	mu    sync.RWMutex
	carts map[model.UserID][]model.CartItem
}

func NewCart() *Cart {
	return &Cart{
		carts: map[model.UserID][]model.CartItem{},
	}
}

func (p *Cart) Add(_ context.Context, req model.AddCartItemRequest) error {
	p.mu.Lock()
	defer p.mu.Unlock()

	cart := p.carts[req.UserID]

reqItemsLoop:
	for _, reqItem := range req.Items {
		for i := range cart {
			item := &cart[i]
			if item.SKU == reqItem.SKU {
				item.Count += reqItem.Count
				continue reqItemsLoop
			}
		}
		cart = append(cart, model.CartItem{SKU: reqItem.SKU, Count: reqItem.Count})
	}

	p.carts[req.UserID] = cart
	return nil
}

func (p *Cart) Delete(_ context.Context, req model.DeleteCartItemRequest) error {
	p.mu.Lock()
	defer p.mu.Unlock()

	cart := p.carts[req.UserID]
	for i := range cart {
		item := &cart[i]
		if item.SKU == req.SKU {
			n := len(cart)
			cart[i] = cart[n-1]
			cart = cart[:n-1]
			p.carts[req.UserID] = cart
			return nil
		}
	}

	return model.ErrNotFound
}

func (p *Cart) List(_ context.Context, userID model.UserID) ([]model.CartItem, error) {
	p.mu.RLock()
	defer p.mu.RUnlock()

	cart := p.carts[userID]
	if cart == nil {
		return nil, model.ErrNotFound
	}

	return slices.Clone(cart), nil
}

func (p *Cart) Clear(_ context.Context, userID model.UserID) error {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete(p.carts, userID)
	return nil
}

var _ service.CartStorage = &Cart{}

// === cart/internal/model/dto.go ===
package model

type AddCartItemRequest struct {
	Token  string
	UserID UserID
	Items  []CartItem
}

type DeleteCartItemRequest struct {
	UserID UserID
	SKU    SKU
}

type GetProductRequest struct {
	Token string
	SKU   SKU
}

type GetProductResponse struct {
	Name  string
	Price uint32
}

type CartListItem struct {
	SKU   SKU
	Count uint16
	Name  string
	Price uint32
}

type CartListRequest struct {
	UserID UserID
	Token  string
}

type CartListResponse struct {
	Items      []CartListItem
	TotalPrice uint32
}

type OrderItem = CartItem

type OrderCreateRequest struct {
	UserID UserID
	Items  []OrderItem
}

// === cart/internal/model/error.go ===
package model

import "errors"

var (
	ErrInternalError      = errors.New("internal error")
	ErrUnauthorized       = errors.New("unauthorized")
	ErrNotFound           = errors.New("not found")
	ErrPreconditionFailed = errors.New("precondition failed")
)

// === cart/internal/model/model.go ===
package model

type (
	SKU     int32
	UserID  int64
	OrderID int64
)

type Cart struct {
	UserID UserID
	Items  []CartItem
}

type CartItem struct {
	SKU   SKU
	Count uint16
}

// === cart/internal/service/cart.go ===
package service

import (
	"context"
	"errors"
	"fmt"
	"route256/cart/internal/model"
)

type CartStorage interface {
	Add(ctx context.Context, req model.AddCartItemRequest) error
	Delete(ctx context.Context, req model.DeleteCartItemRequest) error
	List(ctx context.Context, userID model.UserID) ([]model.CartItem, error)
	Clear(ctx context.Context, userID model.UserID) error
}

type OrderStorage interface {
	CreateOrder(ctx context.Context, req model.OrderCreateRequest) (model.OrderID, error)
	GetStockInfo(ctx context.Context, sku model.SKU) (count uint64, err error)
}

type ProductStorage interface {
	GetInfo(ctx context.Context, req model.GetProductRequest) (model.GetProductResponse, error)
}

type Cart struct {
	cart    CartStorage
	order   OrderStorage
	product ProductStorage
}

func NewCart(cart CartStorage, order OrderStorage, product ProductStorage) *Cart {
	return &Cart{
		cart:    cart,
		order:   order,
		product: product,
	}
}

func (p *Cart) Add(ctx context.Context, req model.AddCartItemRequest) error {
	countInCart, err := p.getCountInCart(ctx, req.UserID)
	if err != nil {
		return err
	}
	sreq := model.AddCartItemRequest{
		UserID: req.UserID,
		Items:  make([]model.CartItem, 0, len(req.Items)),
	}
	for _, item := range req.Items {
		if item.Count == 0 {
			// Игнорируем нулевые количества
			continue
		}

		exists, err := p.isProductExists(ctx, req.Token, item.SKU)
		if err != nil {
			return err
		}
		if !exists {
			return model.ErrPreconditionFailed
		}

		count, err := p.getCountInStock(ctx, item.SKU)
		if err != nil {
			return err
		}
		if count < uint64(item.Count+countInCart[item.SKU]) {
			return model.ErrPreconditionFailed
		}

		sreq.Items = append(sreq.Items, item)
	}
	return p.cart.Add(ctx, sreq)
}

func (p *Cart) getCountInCart(ctx context.Context, userID model.UserID) (map[model.SKU]uint16, error) {
	cartItems, err := p.cart.List(ctx, userID)
	if err != nil && !errors.Is(err, model.ErrNotFound) {
		return nil, fmt.Errorf("failed to list cart items: %w", err)
	}
	countInCart := make(map[model.SKU]uint16, len(cartItems))
	for _, item := range cartItems {
		countInCart[item.SKU] = item.Count
	}
	return countInCart, nil
}

func (p *Cart) isProductExists(ctx context.Context, token string, sku model.SKU) (bool, error) {
	_, err := p.product.GetInfo(ctx, model.GetProductRequest{
		Token: token,
		SKU:   sku,
	})
	if errors.Is(err, model.ErrNotFound) {
		// Товар не найден в каталоге, но здесь это не ошибка
		return false, nil
	}
	if err != nil {
		return false, fmt.Errorf("failed to get product info: %w", err)
	}
	return true, nil
}

func (p *Cart) getCountInStock(ctx context.Context, sku model.SKU) (count uint64, _ error) {
	count, err := p.order.GetStockInfo(ctx, sku)
	if errors.Is(err, model.ErrNotFound) {
		// Если товар не найден на складе, считаем его количество равным 0
		return 0, nil
	}
	if err != nil {
		return 0, fmt.Errorf("failed to get product in stock info: %w", err)
	}
	return count, nil
}

func (p *Cart) Delete(ctx context.Context, req model.DeleteCartItemRequest) error {
	err := p.cart.Delete(ctx, req)
	if errors.Is(err, model.ErrNotFound) {
		// Если товара нет в корзине, не возвращаем ошибку, чтобы обеспечить идемпотентность
		return nil
	}
	if err != nil {
		return fmt.Errorf("failed to delete item from cart: %w", err)
	}
	return nil
}

func (p *Cart) List(ctx context.Context, req model.CartListRequest) (resp model.CartListResponse, _ error) {
	log := getLogger(ctx, "Cart.List")

	// Инициализируем список товаров в корзине, чтобы не вернуть nil
	resp.Items = []model.CartListItem{}

	cartItems, err := p.cart.List(ctx, req.UserID)
	if errors.Is(err, model.ErrNotFound) {
		return resp, nil
	}
	if err != nil {
		return resp, fmt.Errorf("failed to list cart items: %w", err)
	}

	var skusToDelete []model.SKU
	for _, item := range cartItems {
		if item.Count == 0 {
			// Товара нет в корзине
			log.Warn("no product in cart, it will be deleted", "SKU", item.SKU)
			skusToDelete = append(skusToDelete, item.SKU)
			continue
		}
		product, err := p.product.GetInfo(ctx, model.GetProductRequest{
			Token: req.Token,
			SKU:   item.SKU,
		})
		if errors.Is(err, model.ErrNotFound) {
			// Товар не найден в каталоге, добавляем в список на удаление
			log.Warn("cart item not found in products, it will be deleted", "SKU", item.SKU)
			skusToDelete = append(skusToDelete, item.SKU)
			continue
		}
		if err != nil {
			return resp, fmt.Errorf("failed to get product info: %w", err)
		}

		// Добавляем товар в ответ
		resp.Items = append(resp.Items, model.CartListItem{
			SKU:   item.SKU,
			Count: item.Count,
			Name:  product.Name,
			Price: product.Price,
		})
		resp.TotalPrice += product.Price * uint32(item.Count)
	}

	// Удаляем несуществующие товары из корзины
	for _, sku := range skusToDelete {
		if err := p.cart.Delete(ctx, model.DeleteCartItemRequest{
			UserID: req.UserID,
			SKU:    sku,
		}); err != nil {
			return resp, fmt.Errorf("failed to delete invalid cart item: %w", err)
		}
	}

	return resp, nil
}

func (p *Cart) Clear(ctx context.Context, userID model.UserID) error {
	return p.cart.Clear(ctx, userID)
}

func (p *Cart) Checkout(ctx context.Context, userID model.UserID) (model.OrderID, error) {
	log := getLogger(ctx, "Cart.Checkout")

	cartItems, err := p.cart.List(ctx, userID)
	if err != nil {
		return 0, fmt.Errorf("failed to list cart items: %w", err)
	}
	if len(cartItems) == 0 {
		return 0, fmt.Errorf("cart is empty: %w", model.ErrNotFound)
	}

	orderID, err := p.order.CreateOrder(ctx, model.OrderCreateRequest{
		UserID: userID,
		Items:  cartItems,
	})
	if err != nil {
		return 0, fmt.Errorf("failed to create order: %w", err)
	}

	if err := p.cart.Clear(ctx, userID); err != nil {
		// Логируем ошибку очистки корзины, но не прерываем выполнение
		log.Error("failed to clear cart after checkout", "error", err)
	}

	return orderID, nil
}

// === cart/internal/service/logger.go ===
package service

import (
	"context"
	"log/slog"
	"route256/cart/pkg/http/middleware"
)

func getLogger(ctx context.Context, op string) *slog.Logger {
	return middleware.GetLoggerFromContextOrDefault(ctx).
		With("op", "service#"+op)
}

// === cart/pkg/http/middleware/logging.go ===
package middleware

import (
	"cmp"
	"context"
	"log/slog"
	"math/rand/v2"
	"net/http"
	"runtime/debug"
	"sync/atomic"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type loggerContextKey struct{}

// ContextWithLogger добавляет логгер в контекст.
func ContextWithLogger(ctx context.Context, log *slog.Logger) context.Context {
	return context.WithValue(ctx, loggerContextKey{}, log)
}

// GetLoggerFromContext возвращает логгер из контекста или nil, если логгер не найден.
func GetLoggerFromContext(ctx context.Context) *slog.Logger {
	if v := ctx.Value(loggerContextKey{}); v != nil {
		return v.(*slog.Logger)
	}
	return nil
}

// GetLoggerFromContextOrDefault возвращает логгер из контекста или логгер по умолчанию,
// если логгер не найден.
func GetLoggerFromContextOrDefault(ctx context.Context) *slog.Logger {
	return cmp.Or(GetLoggerFromContext(ctx), slog.Default())
}

// Logging создает middleware для логирования HTTP-запросов.
func Logging(log *slog.Logger, h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log := log.With("httpReqID", rand.Uint64())

		url := r.URL.String()
		log.Debug("http request begin", "fromAddr", r.RemoteAddr, "method", r.Method, "url", url)

		w = newWriteHeaderHook(w, func(statusCode int) {
			log.Debug("http request end", "statusCode", statusCode, "url", url)
		})

		ctx := ContextWithLogger(r.Context(), log)
		r = r.WithContext(ctx)

		defer func() {
			if p := recover(); p != nil {
				log.Error("*** panic recovered ***", "panic", p, "stack", debug.Stack())
				http.Error(w, "internal error", 500)
			}
		}()

		h.ServeHTTP(w, r)
	})
}

type writeHeaderHook struct {
	http.ResponseWriter
	hook func(statusCode int)
	flag atomic.Bool
}

func newWriteHeaderHook(w http.ResponseWriter, hook func(statusCode int)) *writeHeaderHook {
	return &writeHeaderHook{
		ResponseWriter: w,
		hook:           hook,
	}
}

func (hk *writeHeaderHook) WriteHeader(statusCode int) {
	if !hk.flag.Swap(true) {
		hk.hook(statusCode)
		hk.ResponseWriter.WriteHeader(statusCode)
	}
}

func (hk *writeHeaderHook) Write(b []byte) (int, error) {
	hk.WriteHeader(http.StatusOK)
	return hk.ResponseWriter.Write(b)
}

func GRPCLogging(log *slog.Logger) grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (_ interface{}, err error) {
		log := log.With("grpcReqID", rand.Uint64())
		log.Debug("grpc request begin", "fromAddr", "???", "method", info.FullMethod, "req", req)

		defer func() {
			if p := recover(); p != nil {
				log.Error("*** panic recovered ***", "panic", p, "stack", debug.Stack())
				err = status.Error(codes.Internal, "internal error")
			}
		}()

		resp, err := handler(ContextWithLogger(ctx, log), req)
		log.Debug("grpc request end", "status", status.Code(err), "resp", resp)

		return resp, err
	}
}

// === loms/cmd/app/main.go ===
package main

import (
	"os"
	"route256/loms/internal/app"
)

func main() {
	os.Exit(app.Run())
}

// === loms/internal/app/app.go ===
package app

import (
	"context"
	"log/slog"
	"net"
	"net/http"
	"os"
	"os/signal"
	"route256/cart/pkg/http/middleware"
	"route256/loms/internal/config"
	grpcHandler "route256/loms/internal/grpc/handler"
	httpHandler "route256/loms/internal/http/handler"
	"route256/loms/internal/memstor"
	"route256/loms/internal/service"
	"route256/loms/pkg/api/order/v1"
	"route256/loms/pkg/api/stock/v1"
	"sync"
	"syscall"

	"google.golang.org/grpc"
)

func Run() int {
	cfg, err := config.Load()
	if err != nil {
		slog.Error("can't load config", "error", err)
		return 1
	}

	setupDefaultLogger(cfg.Logger)

	lomsService := createLOMSService()

	// Создаем менеджер и добавляем серверы
	manager := &serverManager{}
	manager.AddServer(newHTTPServer(cfg.HTTPServer, lomsService))
	manager.AddServer(newGRPCServer(cfg.GRPCServer, lomsService))

	// Запускаем серверы
	manager.StartAll()

	// Ожидаем сигнала или падения серверов
	manager.WaitForShutdown()

	// Завершаем работу серверов
	ctx, cancel := context.WithTimeout(context.Background(), cfg.ShutdownTimeout)
	defer cancel()
	manager.StopAll(ctx)

	if manager.failed {
		return 1
	}

	return 0
}

func setupDefaultLogger(cfg *config.Logger) {
	var handler slog.Handler
	if cfg.PlainText {
		handler = slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: cfg.Level})
	} else {
		handler = slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{Level: cfg.Level})
	}
	slog.SetDefault(slog.New(handler).With("app", "loms"))
}

func createLOMSService() *service.LOMS {
	// TODO: here using memstore for test only
	return service.NewLOMS(
		memstor.NewOrder(),
		memstor.NewRandomStock(productsForTest),
	)
}

// server представляет интерфейс для управления сервером.
type server interface {
	Start(fail chan<- struct{}) // Запуск сервера
	Stop(ctx context.Context)   // Остановка сервера
}

// serverManager управляет несколькими серверами.
type serverManager struct {
	servers []server
	fail    chan struct{}
	failed  bool
	once    sync.Once
}

// AddServer добавляет сервер в менеджер.
func (m *serverManager) AddServer(server server) {
	m.servers = append(m.servers, server)
}

// StartAll запускает все серверы.
func (m *serverManager) StartAll() {
	m.once.Do(func() {
		m.fail = make(chan struct{}, len(m.servers))
		for _, svr := range m.servers {
			go svr.Start(m.fail)
		}
	})
}

// StopAll останавливает все серверы.
func (m *serverManager) StopAll(ctx context.Context) {
	var wg sync.WaitGroup
	for _, svr := range m.servers {
		wg.Add(1)
		go func(s server) {
			defer wg.Done()
			s.Stop(ctx)
		}(svr)
	}
	wg.Wait()
}

// WaitForShutdown ожидает сигнала завершения или падения серверов.
func (m *serverManager) WaitForShutdown() {
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)

	select {
	case <-c:
		slog.Info("shutdown by signal")
	case <-m.fail:
		slog.Info("shutdown by server failure")
		m.failed = true
	}
}

type httpServer struct {
	server *http.Server
}

func newHTTPServer(cfg *config.HTTPServer, lomsService *service.LOMS) *httpServer {
	mux := http.NewServeMux()
	mux.HandleFunc("GET /ping", pong)
	mux.Handle("POST /order/create", httpHandler.CreateOrder(lomsService.CreateOrder))
	mux.Handle("POST /order/info", httpHandler.GetOrderInfo(lomsService.GetOrderInfo))
	mux.Handle("POST /order/pay", httpHandler.PayOrder(lomsService.PayOrder))
	mux.Handle("POST /order/cancel", httpHandler.CancelOrder(lomsService.CancelOrder))
	mux.Handle("POST /stock/info", httpHandler.GetStockInfo(lomsService.GetStockInfo))

	return &httpServer{
		server: &http.Server{
			Addr:         cfg.Addr,
			Handler:      middleware.Logging(slog.Default(), mux),
			ReadTimeout:  cfg.ReadTimeout,
			WriteTimeout: cfg.WriteTimeout,
		},
	}
}

func pong(w http.ResponseWriter, h *http.Request) {
	if _, err := w.Write([]byte("pong")); err != nil {
		slog.Error("ping: can't write pong", "error", err)
	}
}

func (s *httpServer) Start(fail chan<- struct{}) {
	slog.Info("http server startup", "addr", s.server.Addr)
	if err := s.server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		slog.Error("http server failed", "error", err)
		fail <- struct{}{} // Отправляем сигнал о падении
	}
}

func (s *httpServer) Stop(ctx context.Context) {
	if err := s.server.Shutdown(ctx); err != nil {
		slog.Error("failed to stop http server", "error", err)
	}
}

type grpcServer struct {
	server *grpc.Server
	cfg    *config.GRPCServer
}

func newGRPCServer(cfg *config.GRPCServer, lomsService *service.LOMS) *grpcServer {
	server := grpc.NewServer(grpc.UnaryInterceptor(middleware.GRPCLogging(slog.Default())))
	order.RegisterOrderServer(server, grpcHandler.NewOrder(lomsService))
	stock.RegisterStockServer(server, grpcHandler.NewStock(lomsService))

	return &grpcServer{
		server: server,
		cfg:    cfg,
	}
}

func (s *grpcServer) Start(fail chan<- struct{}) {
	slog.Info("grcp server startup", "addr", s.cfg.Addr)
	lis, err := net.Listen("tcp", s.cfg.Addr)
	if err != nil {
		slog.Error("grpc server failed", "error", err)
		fail <- struct{}{} // Отправляем сигнал о падении
		return
	}
	if err := s.server.Serve(lis); err != nil {
		slog.Error("grpc server failed", "error", err)
		fail <- struct{}{} // Отправляем сигнал о падении
	}
}

func (s *grpcServer) Stop(ctx context.Context) {
	stopped := make(chan struct{})
	go func() {
		s.server.GracefulStop()
		close(stopped)
	}()
	select {
	case <-ctx.Done():
		s.server.Stop()
	case <-stopped:
	}
}

// === loms/internal/app/pong.go ===
package app

// === loms/internal/app/producs.go ===
package app

import "route256/loms/internal/model"

var productsForTest = []model.SKU{
	1076963,
	1148162,
	1625903,
	2618151,
	2956315,
	2958025,
	3596599,
	3618852,
	4288068,
	4465995,
}

// === loms/internal/config/config.go ===
package config

import (
	"log/slog"
	"time"
)

type Logger struct {
	Level     slog.Level
	PlainText bool
}

type HTTPServer struct {
	Addr         string
	ReadTimeout  time.Duration
	WriteTimeout time.Duration
}

type GRPCServer struct {
	Addr string
}

type Config struct {
	ShutdownTimeout time.Duration
	Logger          *Logger
	HTTPServer      *HTTPServer
	GRPCServer      *GRPCServer
}

func Load() (Config, error) {
	return Config{
		ShutdownTimeout: 30 * time.Second,
		Logger: &Logger{
			Level:     slog.LevelDebug,
			PlainText: true,
		},
		HTTPServer: &HTTPServer{
			Addr:         ":8080",
			ReadTimeout:  10 * time.Second,
			WriteTimeout: 10 * time.Second,
		},
		GRPCServer: &GRPCServer{
			Addr: ":50051",
		},
	}, nil
}

// === loms/internal/grpc/handler/maperr.go ===
package handler

import (
	"context"
	"errors"
	"route256/cart/pkg/http/middleware"
	"route256/loms/internal/model"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func mapError(ctx context.Context, err error) error {
	switch {
	case errors.Is(err, model.ErrNotFound):
		return status.Error(codes.NotFound, err.Error())
	case errors.Is(err, model.ErrPreconditionFailed):
		return status.Error(codes.FailedPrecondition, err.Error())
	case errors.Is(err, model.ErrInternalError):
		return status.Error(codes.Internal, err.Error())
	}
	log := middleware.GetLoggerFromContextOrDefault(ctx)
	log.Warn("unhandled error", "error", err)
	return status.Error(codes.Internal, model.ErrInternalError.Error())
}

// === loms/internal/grpc/handler/order.go ===
package handler

import (
	"context"
	"route256/loms/internal/model"
	"route256/loms/pkg/api/order/v1"
)

type LomsService interface {
	CreateOrder(ctx context.Context, req model.CreateOrderRequest) (resp model.CreateOrderResponse, err error)
	GetOrderInfo(ctx context.Context, orderID model.OrderID) (resp model.Order, err error)
	PayOrder(ctx context.Context, orderID model.OrderID) error
	CancelOrder(ctx context.Context, orderID model.OrderID) error
	GetStockInfo(ctx context.Context, sku model.SKU) (count uint64, err error)
}

type Order struct {
	order.UnimplementedOrderServer
	service LomsService
}

func NewOrder(service LomsService) *Order {
	return &Order{service: service}
}

func (o Order) Create(ctx context.Context, req *order.CreateRequest) (*order.CreateResponse, error) {
	mreq := model.CreateOrderRequest{
		UserID: model.UserID(req.User),
		Items:  make([]model.OrderItem, 0, len(req.Items)),
	}
	for _, item := range req.Items {
		mreq.Items = append(mreq.Items, model.OrderItem{
			SKU:   model.SKU(item.Sku),
			Count: uint16(item.Count),
		})
	}
	mresp, err := o.service.CreateOrder(ctx, mreq)
	if err != nil {
		return nil, mapError(ctx, err)
	}
	return &order.CreateResponse{OrderID: int64(mresp.OrderID)}, nil
}

func (o Order) GetInfo(ctx context.Context, req *order.GetInfoRequest) (*order.GetInfoResponse, error) {
	mresp, err := o.service.GetOrderInfo(ctx, model.OrderID(req.OrderID))
	if err != nil {
		return nil, mapError(ctx, err)
	}

	resp := &order.GetInfoResponse{
		Status: order.OrderStatus(mresp.Status),
		User:   int64(mresp.UserID),
		Items:  make([]*order.Item, 0, len(mresp.Items)),
	}
	for _, item := range mresp.Items {
		resp.Items = append(resp.Items, &order.Item{
			Sku:   int32(item.SKU),
			Count: uint32(item.Count),
		})
	}

	return resp, nil
}

func (o Order) Pay(ctx context.Context, req *order.PayRequest) (*order.PayResponse, error) {
	if err := o.service.PayOrder(ctx, model.OrderID(req.OrderID)); err != nil {
		return nil, mapError(ctx, err)
	}
	return &order.PayResponse{}, nil
}

func (o Order) Cancel(ctx context.Context, req *order.CancelRequest) (*order.CancelResponse, error) {
	if err := o.service.CancelOrder(ctx, model.OrderID(req.OrderID)); err != nil {
		return nil, mapError(ctx, err)
	}
	return &order.CancelResponse{}, nil
}

// === loms/internal/grpc/handler/stock.go ===
package handler

import (
	"context"
	"route256/loms/internal/model"
	"route256/loms/pkg/api/stock/v1"
)

type StockService interface {
	GetStockInfo(ctx context.Context, sku model.SKU) (count uint64, err error)
}

type Stock struct {
	stock.UnimplementedStockServer
	service StockService
}

func NewStock(service StockService) *Stock {
	return &Stock{service: service}
}

func (s Stock) GetInfo(ctx context.Context, req *stock.GetInfoRequest) (*stock.GetInfoResponse, error) {
	count, err := s.service.GetStockInfo(ctx, model.SKU(req.Sku))
	if err != nil {
		return nil, mapError(ctx, err)
	}
	return &stock.GetInfoResponse{Count: count}, nil
}

// === loms/internal/http/handler/error.go ===
package handler

import "fmt"

type httpError struct {
	Code    int
	Message string
}

func (e *httpError) Error() string {
	return fmt.Sprintf("%d: %s", e.Code, e.Message)
}

var (
	errInternalError      = &httpError{500, "internal error"}
	errBadRequest         = &httpError{400, "bad request"}
	errUnauthorized       = &httpError{401, "unauthorized"}
	errNotFound           = &httpError{404, "not found"}
	errPreconditionFailed = &httpError{412, "precondition failed"}
)

var _ = errUnauthorized

// === loms/internal/http/handler/helper.go ===
package handler

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"log/slog"
	"net/http"
	"reflect"
	"route256/cart/pkg/http/middleware"
	"route256/loms/internal/model"
)

type helper struct {
	w  http.ResponseWriter
	r  *http.Request
	lg *slog.Logger
}

func newHelper(w http.ResponseWriter, r *http.Request, op string) helper {
	return helper{
		w: w,
		r: r,
		lg: middleware.GetLoggerFromContextOrDefault(r.Context()).
			With("op", "handler#"+op),
	}
}

func (x helper) ctx() context.Context {
	return x.r.Context()
}

func (x helper) log() *slog.Logger {
	return x.lg
}

func (x helper) checkPOSTMethod() bool {
	if x.r.Method != http.MethodPost {
		x.log().Error("logical error: using for a non-POST request", "method", x.r.Method, "url", x.r.URL)
		x.writeError(errInternalError)
		return false
	}
	return true
}

func (x helper) getAuthToken() string {
	return x.r.Header.Get("X-Authtoken")
}

func (x helper) ReadBody() ([]byte, bool) {
	body, err := io.ReadAll(x.r.Body)
	if err != nil {
		x.log().Error("can't read request body", "error", err)
		x.writeError(errInternalError)
		return nil, false
	}
	return body, true
}

func (x helper) decodeBody(req any) bool {
	body, ok := x.ReadBody()
	if !ok {
		return false
	}
	if err := json.Unmarshal(body, req); err != nil {
		x.log().Debug("can't unmarshal request body", "error", err)
		x.writeError(errBadRequest)
		return false
	}
	return true
}

type Validator interface {
	Validate() error
}

func (x helper) validateRequest(req any) bool {
	if req2, ok := req.(Validator); !ok {
		x.log().Error("request not implement Validator", "reqType", reflect.TypeOf(req))
		x.writeError(errInternalError)
		return false
	} else if err := req2.Validate(); err != nil {
		x.log().Debug("can't validate request", "error", err)
		x.writeError(errBadRequest)
		return false
	}
	return true
}

func (x helper) decodeBodyAndValidateRequest(req any) bool {
	return x.decodeBody(req) && x.validateRequest(req)
}

func (x helper) writeResponse(status int, resp any) {
	jsonData, err := json.Marshal(resp)
	if err != nil {
		x.log().Error("can't marshal response", "error", err)
		x.writeError(errInternalError)
		return
	}

	x.w.Header().Add("content-type", "application/json")
	x.w.WriteHeader(status)

	if _, err := x.w.Write(jsonData); err != nil {
		x.log().Error("can't write response", "error", err)
		return
	}
}

func (x helper) writeError(err error) {
	var httpErr *httpError
	switch {
	case errors.As(err, &httpErr):
	case errors.Is(err, model.ErrNotFound):
		httpErr = errNotFound
	case errors.Is(err, model.ErrPreconditionFailed):
		httpErr = errPreconditionFailed
	case errors.Is(err, model.ErrInternalError):
		httpErr = errInternalError
	default:
		x.log().Warn("unhandled error", "error", err)
		httpErr = errInternalError
	}
	http.Error(x.w, httpErr.Message, httpErr.Code)
}

// === loms/internal/http/handler/loms.go ===
package handler

import (
	"context"
	"errors"
	"net/http"
	"route256/loms/internal/model"
	"strconv"
)

type orderItem struct {
	SKU   model.SKU `json:"sku"`
	Count uint16    `json:"count"`
}

type createOrderRequest struct {
	User  model.UserID `json:"user"`
	Items []orderItem  `json:"items"`
}

func (req createOrderRequest) Validate() error {
	var errs []error
	if req.User <= 0 {
		errs = append(errs, errors.New("user must be > 0"))
	}
	if len(req.Items) == 0 {
		errs = append(errs, errors.New("items cannot be empty"))
	}
	for i, item := range req.Items {
		if item.SKU <= 0 {
			errs = append(errs, errors.New("item["+strconv.Itoa(i)+"]: sku must be > 0"))
		}
		if item.Count <= 0 {
			errs = append(errs, errors.New("item["+strconv.Itoa(i)+"]: count must be > 0"))
		}
	}
	return errors.Join(errs...)
}

type createOreserResponce struct {
	OrderID model.OrderID `json:"orderID"`
}

func CreateOrder(crateFunc func(ctx context.Context, req model.CreateOrderRequest) (resp model.CreateOrderResponse, err error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		x := newHelper(w, r, "CreateOrder")

		var req createOrderRequest
		if !x.decodeBodyAndValidateRequest(&req) {
			return
		}

		mreq := model.CreateOrderRequest{
			UserID: req.User,
			Items:  make([]model.OrderItem, 0, len(req.Items)),
		}
		for _, item := range req.Items {
			mreq.Items = append(mreq.Items, model.OrderItem{
				SKU:   item.SKU,
				Count: item.Count,
			})
		}

		mresp, err := crateFunc(x.ctx(), mreq)
		if err != nil {
			x.writeError(err)
			return
		}

		x.writeResponse(200, createOreserResponce{mresp.OrderID}) // or 201 ?
	}
}

type getOrderRequest struct {
	OrderID model.OrderID `json:"orderID"`
}

type getOrderInfoRequest = getOrderRequest

func (req getOrderInfoRequest) Validate() error {
	if req.OrderID <= 0 {
		return errors.New("orderID must be > 0")
	}
	return nil
}

type getOrderInfoResponse struct {
	Status string       `json:"status"`
	User   model.UserID `json:"user"`
	Items  []orderItem  `json:"items"`
}

func GetOrderInfo(getFunc func(ctx context.Context, orderID model.OrderID) (resp model.Order, err error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		x := newHelper(w, r, "GetOrederInfo")

		var req getOrderInfoRequest
		if !x.decodeBodyAndValidateRequest(&req) {
			return
		}

		mresp, err := getFunc(x.ctx(), req.OrderID)
		if err != nil {
			x.writeError(err)
			return
		}

		resp := getOrderInfoResponse{
			Status: mresp.Status.String(),
			User:   mresp.UserID,
			Items:  make([]orderItem, 0, len(mresp.Items)),
		}
		for _, item := range mresp.Items {
			resp.Items = append(resp.Items, orderItem{
				SKU:   item.SKU,
				Count: item.Count,
			})
		}

		x.writeResponse(200, resp)
	}
}

type payOrderRequest = getOrderRequest

func PayOrder(payFunc func(ctx context.Context, orderID model.OrderID) error) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		x := newHelper(w, r, "PayOrder")

		var req payOrderRequest
		if !x.decodeBodyAndValidateRequest(&req) {
			return
		}

		if err := payFunc(x.ctx(), req.OrderID); err != nil {
			x.writeError(err)
			return
		}

		x.writeResponse(200, struct{}{})
	}
}

type cancelOrderRequest = getOrderRequest

func CancelOrder(cancelFunc func(ctx context.Context, orderID model.OrderID) error) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		x := newHelper(w, r, "CancelOrder")

		var req cancelOrderRequest
		if !x.decodeBodyAndValidateRequest(&req) {
			return
		}

		if err := cancelFunc(x.ctx(), req.OrderID); err != nil {
			x.writeError(err)
			return
		}

		x.writeResponse(200, struct{}{})
	}
}

type getStockInfoRequest struct {
	SKU model.SKU `json:"sku"`
}

func (req getStockInfoRequest) Validate() error {
	if req.SKU <= 0 {
		return errors.New("sku must be > 0")
	}
	return nil
}

type getStockInfoResponse struct {
	Count uint64 `json:"count"`
}

func GetStockInfo(getFunc func(ctx context.Context, sku model.SKU) (count uint64, err error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		x := newHelper(w, r, "GetStockInfo")

		var req getStockInfoRequest
		if !x.decodeBodyAndValidateRequest(&req) {
			return
		}

		count, err := getFunc(x.ctx(), req.SKU)
		if err != nil {
			x.writeError(err)
			return
		}

		x.writeResponse(200, getStockInfoResponse{count})
	}
}

// === loms/internal/memstor/order.go ===
package memstor

import (
	"context"
	"route256/loms/internal/model"
	"route256/loms/internal/service"
	"slices"
	"sync"
)

type Order struct {
	mu      sync.RWMutex
	idCount model.OrderID
	items   map[model.OrderID]model.Order
}

func NewOrder() *Order {
	return &Order{
		items: map[model.OrderID]model.Order{},
	}
}

func (o *Order) newOrderID() model.OrderID {
	o.idCount++
	return o.idCount
}

// Create implements service.OrderStorage.
func (o *Order) Create(_ context.Context, req model.CreateOrderRequest) (model.CreateOrderResponse, error) {
	o.mu.Lock()
	defer o.mu.Unlock()

	orderID := o.newOrderID()
	status := model.OrderStatusNew

	o.items[orderID] = model.Order{
		Status: status,
		UserID: req.UserID,
		Items:  slices.Clone(req.Items),
	}

	return model.CreateOrderResponse{
		OrderID: orderID,
		Status:  status,
	}, nil
}

// GetByID implements service.OrderStorage.
func (o *Order) GetByID(_ context.Context, orderID model.OrderID) (model.Order, error) {
	o.mu.RLock()
	defer o.mu.RUnlock()

	order, exists := o.items[orderID]
	if !exists {
		return model.Order{}, model.ErrNotFound
	}

	return order, nil
}

// SetStatus implements service.OrderStorage.
func (o *Order) SetStatus(_ context.Context, req model.SetOrderStatusRequest) error {
	o.mu.Lock()
	defer o.mu.Unlock()

	order, exists := o.items[req.OrderID]
	if !exists {
		return model.ErrNotFound
	}

	order.Status = req.Status
	o.items[req.OrderID] = order
	return nil
}

var _ service.OrderStorage = &Order{}

// === loms/internal/memstor/stock.go ===
package memstor

import (
	"context"
	"fmt"
	"math/rand/v2"
	"route256/loms/internal/model"
	"route256/loms/internal/service"
	"sync"
)

type stockItem struct {
	count    uint64
	reserved uint64
}

func (si stockItem) available() uint64 {
	return si.count - si.reserved
}

type Stock struct {
	mu    sync.RWMutex
	items map[model.SKU]stockItem
}

func NewStock() *Stock {
	return &Stock{
		items: map[model.SKU]stockItem{},
	}
}

func NewRandomStock(producs []model.SKU) *Stock {
	const maxProductCount = 10

	items := make([]StockItem, 0, len(producs))
	for _, sku := range producs {
		items = append(items, StockItem{
			SKU:   sku,
			Count: rand.Uint64N(maxProductCount),
		})
	}

	stock := NewStock()
	stock.Init(items)
	return stock
}

type StockItem struct {
	SKU   model.SKU
	Count uint64
}

func (s *Stock) Init(items []StockItem) {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.items = make(map[model.SKU]stockItem)
	for _, item := range items {
		s.items[item.SKU] = stockItem{count: item.Count}
	}
}

// GetInfo implements service.StockStorage.
func (s *Stock) GetInfo(_ context.Context, sku model.SKU) (count uint64, err error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	item, exists := s.items[sku]
	if !exists {
		return 0, model.ErrNotFound
	}
	return item.available(), nil
}

// Reserve implements service.StockStorage.
func (s *Stock) Reserve(_ context.Context, orderItems []model.OrderItem) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	stockItems := make([]stockItem, 0, len(orderItems))
	for _, orderItem := range orderItems {
		stockItems = append(stockItems, s.items[orderItem.SKU])
	}

	for i := range stockItems {
		if stockItems[i].available() < uint64(orderItems[i].Count) {
			return fmt.Errorf("insufficient available SKU=%v", orderItems[i].SKU)
		}
		stockItems[i].reserved += uint64(orderItems[i].Count)
	}

	for i := range stockItems {
		s.items[orderItems[i].SKU] = stockItems[i]
	}

	return nil
}

// ReserveCancel implements service.StockStorage.
func (s *Stock) ReserveCancel(_ context.Context, orderItems []model.OrderItem) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	stockItems := make([]stockItem, 0, len(orderItems))
	for _, orderItem := range orderItems {
		stockItems = append(stockItems, s.items[orderItem.SKU])
	}

	for i := range stockItems {
		if stockItems[i].reserved < uint64(orderItems[i].Count) {
			return fmt.Errorf("insufficient reserved SKU=%v", orderItems[i].SKU)
		}
		stockItems[i].reserved -= uint64(orderItems[i].Count)
	}

	for i := range stockItems {
		s.items[orderItems[i].SKU] = stockItems[i]
	}

	return nil
}

// ReserveRemove implements service.StockStorage.
func (s *Stock) ReserveRemove(_ context.Context, orderItems []model.OrderItem) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	stockItems := make([]stockItem, 0, len(orderItems))
	for _, orderItem := range orderItems {
		stockItems = append(stockItems, s.items[orderItem.SKU])
	}

	for i := range stockItems {
		if stockItems[i].reserved < uint64(orderItems[i].Count) {
			return fmt.Errorf("insufficient reserved SKU=%v", orderItems[i].SKU)
		}
		n := uint64(orderItems[i].Count)
		stockItems[i].count -= n
		stockItems[i].reserved -= n
	}

	for i := range stockItems {
		s.items[orderItems[i].SKU] = stockItems[i]
	}

	return nil
}

var _ service.StockStorage = &Stock{}

// === loms/internal/model/dto.go ===
package model

type CreateOrderRequest struct {
	UserID UserID
	Items  []OrderItem
}

type CreateOrderResponse struct {
	OrderID OrderID
	Status  OrderStatus
}

type SetOrderStatusRequest = CreateOrderResponse

// === loms/internal/model/error.go ===
package model

import "errors"

var (
	ErrInternalError      = errors.New("internal error")
	ErrNotFound           = errors.New("not found")
	ErrPreconditionFailed = errors.New("precondition failed")
)

// === loms/internal/model/model.go ===
package model

type (
	UserID  int64
	SKU     int32
	OrderID int64
)

type OrderItem struct {
	SKU   SKU
	Count uint16
}

type Order struct {
	Status OrderStatus
	UserID
	Items []OrderItem
}

// === loms/internal/model/order_status.go ===
package model

import (
	"encoding/json"
	"fmt"
	"strconv"
)

type OrderStatus int

const (
	_ OrderStatus = iota
	OrderStatusNew
	OrderStatusAwaitingPayment
	OrderStatusFailed
	OrderStatusPayed
	OrderStatusCancelled
)

func ParseOrderStatus(s string) (OrderStatus, error) {
	switch s {
	case "new":
		return OrderStatusNew, nil
	case "awaiting payment":
		return OrderStatusAwaitingPayment, nil
	case "failed":
		return OrderStatusFailed, nil
	case "payed":
		return OrderStatusPayed, nil
	case "cancelled":
		return OrderStatusCancelled, nil
	}
	return 0, fmt.Errorf("ParseOrderStatus: unknown value %q", s)
}

func (os OrderStatus) String() string {
	switch os {
	case OrderStatusNew:
		return "new"
	case OrderStatusAwaitingPayment:
		return "awaiting payment"
	case OrderStatusFailed:
		return "failed"
	case OrderStatusPayed:
		return "payed"
	case OrderStatusCancelled:
		return "cancelled"
	default:
		return fmt.Sprintf("OrderStatus(%d)", os)
	}
}

// MarshalJSON implements json.Marshaler.
func (os OrderStatus) MarshalJSON() ([]byte, error) {
	return []byte(os.String()), nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (os *OrderStatus) UnmarshalJSON(b []byte) error {
	if string(b) == "null" {
		return nil
	}
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return fmt.Errorf("OrderSttus.UnmarshalJSON: %w", err)
	}
	v, err := ParseOrderStatus(s)
	if err != nil {
		return err
	}
	*os = v
	return nil
}

var _ json.Marshaler = OrderStatus(0)
var _ json.Unmarshaler = new(OrderStatus)

// === loms/internal/service/logger.go ===
package service

import (
	"context"
	"log/slog"
	"route256/cart/pkg/http/middleware"
)

func getLogger(ctx context.Context, op string) *slog.Logger {
	return middleware.GetLoggerFromContextOrDefault(ctx).
		With("op", "service#"+op)
}

// === loms/internal/service/loms.go ===
package service

import (
	"context"
	"route256/loms/internal/model"
)

type OrderStorage interface {
	Create(ctx context.Context, req model.CreateOrderRequest) (model.CreateOrderResponse, error)
	SetStatus(ctx context.Context, req model.SetOrderStatusRequest) error
	GetByID(ctx context.Context, orderID model.OrderID) (model.Order, error)
}

type StockStorage interface {
	Reserve(ctx context.Context, items []model.OrderItem) error
	ReserveRemove(ctx context.Context, items []model.OrderItem) error
	ReserveCancel(ctx context.Context, items []model.OrderItem) error
	GetInfo(ctx context.Context, sku model.SKU) (count uint64, err error)
}

type LOMS struct {
	order OrderStorage
	stock StockStorage
}

func NewLOMS(order OrderStorage, stock StockStorage) *LOMS {
	return &LOMS{
		order: order,
		stock: stock,
	}
}

func (p *LOMS) CreateOrder(ctx context.Context, req model.CreateOrderRequest) (resp model.CreateOrderResponse, err error) {
	log := getLogger(ctx, "LOMS.CreateOrder")

	resp, err = p.order.Create(ctx, req)
	if err != nil {
		return resp, err
	}

	var status model.OrderStatus
	if err := p.stock.Reserve(ctx, req.Items); err != nil {
		status = model.OrderStatusFailed
	} else {
		status = model.OrderStatusAwaitingPayment
	}

	if err := p.order.SetStatus(ctx, model.SetOrderStatusRequest{
		OrderID: resp.OrderID,
		Status:  status,
	}); err != nil {
		log.Error("can't set order status", "error", err)
		return resp, model.ErrInternalError
	}

	resp.Status = status

	if resp.Status == model.OrderStatusAwaitingPayment {
		return resp, nil
	} else {
		return resp, model.ErrPreconditionFailed
	}
}

func (p *LOMS) GetOrderInfo(ctx context.Context, orderID model.OrderID) (resp model.Order, err error) {
	return p.order.GetByID(ctx, orderID)
}

func (p *LOMS) PayOrder(ctx context.Context, orderID model.OrderID) error {
	log := getLogger(ctx, "LOMS.PayOrder")

	orderInfo, err := p.order.GetByID(ctx, orderID)
	if err != nil {
		return err
	}

	if orderInfo.Status != model.OrderStatusAwaitingPayment {
		log.Debug("order status must be 'awaiting payment'", "orderStatus", orderInfo.Status)
		return model.ErrPreconditionFailed
	}

	if err := p.stock.ReserveRemove(ctx, orderInfo.Items); err != nil {
		log.Error("can't reserve remove", "error", err)
		return model.ErrPreconditionFailed
	}

	if err := p.order.SetStatus(ctx, model.SetOrderStatusRequest{
		OrderID: orderID,
		Status:  model.OrderStatusPayed,
	}); err != nil {
		log.Error("can't set order status", "error", err)
		return model.ErrInternalError
	}

	return nil
}

func (p *LOMS) CancelOrder(ctx context.Context, orderID model.OrderID) error {
	log := getLogger(ctx, "LOMS.CancelOrder")

	orderInfo, err := p.order.GetByID(ctx, orderID)
	if err != nil {
		return err
	}

	if orderInfo.Status != model.OrderStatusAwaitingPayment {
		log.Debug("order status must be 'awaiting payment'", "orderStatus", orderInfo.Status)
		return model.ErrPreconditionFailed
	}

	if err := p.stock.ReserveCancel(ctx, orderInfo.Items); err != nil {
		log.Error("can't reserve cancel", "error", err)
		return model.ErrPreconditionFailed
	}

	if err := p.order.SetStatus(ctx, model.SetOrderStatusRequest{
		OrderID: orderID,
		Status:  model.OrderStatusCancelled,
	}); err != nil {
		log.Error("can't set order status", "error", err)
		return model.ErrInternalError
	}

	return nil
}

func (p *LOMS) GetStockInfo(ctx context.Context, sku model.SKU) (count uint64, err error) {
	return p.stock.GetInfo(ctx, sku)
}

// === notifications/cmd/app/main.go ===
package main

func main() {

}

