// === adapter.go ===
package stock

import (
	"context"
	"route256/loms/internal/model"
	"route256/loms/internal/repo/stock/queries"
	"route256/loms/internal/service"

	"github.com/jackc/pgx/v5"
)

type DB interface {
	queries.DBTX
	Begin(ctx context.Context) (pgx.Tx, error)
}

type Adapter struct {
	db      DB
	queries *queries.Queries
}

func New(db DB) *Adapter {
	return &Adapter{
		db:      db,
		queries: queries.New(db),
	}
}

// GetBySKU implements storage.
func (a Adapter) GetBySKU(ctx context.Context, sku model.SKU) (_ model.Stock, err error) {
	qresp, err := a.queries.GetBySKU(ctx, int64(sku))
	if err != nil {
		return model.Stock{}, err
	}
	return model.Stock{
		SKU:       model.SKU(qresp.Sku),
		Available: qresp.Available,
		Reserved:  qresp.Reserved,
	}, nil
}

// Reserve implements storage.
func (a Adapter) Reserve(ctx context.Context, items []model.OrderItem) error {

	queryItems := make([]queries.ReserveParams, 0, len(items))
	for _, item := range items {
		queryItems = append(queryItems, queries.ReserveParams{
			Sku:   int64(item.SKU),
			Count: int64(item.Count)},
		)
	}

	return pgx.BeginFunc(ctx, a.db, func(tx pgx.Tx) error {
		br := a.queries.WithTx(tx).Reserve(ctx, queryItems)

		var queryErr error
		br.QueryRow(func(i int, count int64, err error) {
			if err == queries.ErrBatchAlreadyClosed {
				return
			}
			if err != nil {
				queryErr = err
				br.Close()
				return
			}
			if count == 0 {
				queryErr = model.ErrPreconditionFailed
				br.Close()
				return
			}
		})

		if queryErr != nil {
			return queryErr
		}

		if err := br.Close(); err != nil {
			return err
		}

		return nil
	})
}

// ReserveCancel implements storage.
func (a Adapter) ReserveCancel(ctx context.Context, items []model.OrderItem) error {

	queryItems := make([]queries.ReserveCancelParams, 0, len(items))
	for _, item := range items {
		queryItems = append(queryItems, queries.ReserveCancelParams{
			Sku:   int64(item.SKU),
			Count: int64(item.Count)},
		)
	}

	return pgx.BeginFunc(ctx, a.db, func(tx pgx.Tx) error {
		br := a.queries.WithTx(tx).ReserveCancel(ctx, queryItems)

		var queryErr error
		br.QueryRow(func(i int, count int64, err error) {
			if err == queries.ErrBatchAlreadyClosed {
				return
			}
			if err != nil {
				queryErr = err
				br.Close()
				return
			}
			if count == 0 {
				queryErr = model.ErrPreconditionFailed
				br.Close()
				return
			}
		})

		if queryErr != nil {
			return queryErr
		}

		if err := br.Close(); err != nil {
			return err
		}

		return nil
	})
}

// ReserveRemove implements storage.
func (a Adapter) ReserveRemove(ctx context.Context, items []model.OrderItem) error {

	queryItems := make([]queries.ReserveRemoveParams, 0, len(items))
	for _, item := range items {
		queryItems = append(queryItems, queries.ReserveRemoveParams{
			Sku:   int64(item.SKU),
			Count: int64(item.Count)},
		)
	}

	return pgx.BeginFunc(ctx, a.db, func(tx pgx.Tx) error {
		br := a.queries.WithTx(tx).ReserveRemove(ctx, queryItems)

		var queryErr error
		br.QueryRow(func(i int, count int64, err error) {
			if err == queries.ErrBatchAlreadyClosed {
				return
			}
			if err != nil {
				queryErr = err
				br.Close()
				return
			}
			if count == 0 {
				queryErr = model.ErrPreconditionFailed
				br.Close()
				return
			}
		})

		if queryErr != nil {
			return queryErr
		}

		if err := br.Close(); err != nil {
			return err
		}

		return nil
	})
}

var _ service.StockStorage = Adapter{}

// === queries/batch.go ===
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: batch.go

package queries

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const reserve = `-- name: Reserve :batchone
WITH rows AS (
    UPDATE stock SET available = available - $1, reserved = reserver + $1
    WHERE sku = $2 AND available >= $1
    RETURNING sku
)
SELECT COUNT(*)
`

type ReserveBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type ReserveParams struct {
	Count int64
	Sku   int64
}

func (q *Queries) Reserve(ctx context.Context, arg []ReserveParams) *ReserveBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Count,
			a.Sku,
		}
		batch.Queue(reserve, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &ReserveBatchResults{br, len(arg), false}
}

func (b *ReserveBatchResults) QueryRow(f func(int, int64, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var count int64
		if b.closed {
			if f != nil {
				f(t, count, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&count)
		if f != nil {
			f(t, count, err)
		}
	}
}

func (b *ReserveBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const reserveCancel = `-- name: ReserveCancel :batchone
WITH rows AS (
    UPDATE stock SET available = available + $1, reserved = reserved - $1 
    WHERE sku = $2 AND reserved >= $1
    RETURNING sku
)
SELECT COUNT(*)
`

type ReserveCancelBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type ReserveCancelParams struct {
	Count int64
	Sku   int64
}

func (q *Queries) ReserveCancel(ctx context.Context, arg []ReserveCancelParams) *ReserveCancelBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Count,
			a.Sku,
		}
		batch.Queue(reserveCancel, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &ReserveCancelBatchResults{br, len(arg), false}
}

func (b *ReserveCancelBatchResults) QueryRow(f func(int, int64, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var count int64
		if b.closed {
			if f != nil {
				f(t, count, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&count)
		if f != nil {
			f(t, count, err)
		}
	}
}

func (b *ReserveCancelBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const reserveRemove = `-- name: ReserveRemove :batchone
WITH rows AS (
    UPDATE stock SET reserved = reserved - $1
    WHERE sku = $2 AND reserved >= $1
    RETURNING sku
)
SELECT COUNT(*)
`

type ReserveRemoveBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type ReserveRemoveParams struct {
	Count int64
	Sku   int64
}

func (q *Queries) ReserveRemove(ctx context.Context, arg []ReserveRemoveParams) *ReserveRemoveBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Count,
			a.Sku,
		}
		batch.Queue(reserveRemove, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &ReserveRemoveBatchResults{br, len(arg), false}
}

func (b *ReserveRemoveBatchResults) QueryRow(f func(int, int64, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var count int64
		if b.closed {
			if f != nil {
				f(t, count, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&count)
		if f != nil {
			f(t, count, err)
		}
	}
}

func (b *ReserveRemoveBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

// === queries/db.go ===
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package queries

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
	SendBatch(context.Context, *pgx.Batch) pgx.BatchResults
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}

// === queries/models.go ===
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package queries

type Stock struct {
	Sku       int64
	Available int64
	Reserved  int64
}

// === queries/querier.go ===
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package queries

import (
	"context"
)

type Querier interface {
	GetBySKU(ctx context.Context, sku int64) (Stock, error)
	Reserve(ctx context.Context, arg []ReserveParams) *ReserveBatchResults
	ReserveCancel(ctx context.Context, arg []ReserveCancelParams) *ReserveCancelBatchResults
	ReserveRemove(ctx context.Context, arg []ReserveRemoveParams) *ReserveRemoveBatchResults
}

var _ Querier = (*Queries)(nil)

// === queries/queries.sql.go ===
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package queries

import (
	"context"
)

const getBySKU = `-- name: GetBySKU :one
SELECT sku, available, reserved FROM stock
WHERE sku = $1
`

func (q *Queries) GetBySKU(ctx context.Context, sku int64) (Stock, error) {
	row := q.db.QueryRow(ctx, getBySKU, sku)
	var i Stock
	err := row.Scan(&i.Sku, &i.Available, &i.Reserved)
	return i, err
}

// === create_stock.sql ===
CREATE TABLE stock (
    sku       BIGINT PRIMARY KEY,
    available BIGINT NOT NULL DEFAULT 0 CHECK (available >= 0),
    reserved  BIGINT NOT NULL DEFAULT 0 CHECK (reserved  >= 0)
);

// === queries.sql ===
-- name: GetBySKU :one
SELECT * FROM stock
WHERE sku = @sku;

-- name: Reserve :batchone
WITH rows AS (
    UPDATE stock SET available = available - @count, reserved = reserved + @count
    WHERE sku = @sku AND available >= @count
    RETURNING sku
)
SELECT COUNT(*);

-- name: ReserveCancel :batchone
WITH rows AS (
    UPDATE stock SET available = available + @count, reserved = reserved - @count 
    WHERE sku = @sku AND reserved >= @count
    RETURNING sku
)
SELECT COUNT(*);

-- name: ReserveRemove :batchone
WITH rows AS (
    UPDATE stock SET reserved = reserved - @count
    WHERE sku = @sku AND reserved >= @count
    RETURNING sku
)
SELECT COUNT(*);


