package messages

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/go/classroom-4/teachers/homework/internal/model/messages.ExpenseDB -o ./expense_db_mock_test.go -n ExpenseDBMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/go/classroom-4/teachers/homework/internal/domain"
)

// ExpenseDBMock implements ExpenseDB
type ExpenseDBMock struct {
	t minimock.Tester

	funcAddExpense          func(ctx context.Context, userID int64, kopecks int64, title string, date time.Time) (err error)
	inspectFuncAddExpense   func(ctx context.Context, userID int64, kopecks int64, title string, date time.Time)
	afterAddExpenseCounter  uint64
	beforeAddExpenseCounter uint64
	AddExpenseMock          mExpenseDBMockAddExpense

	funcGetExpenses          func(ctx context.Context, userID int64) (ea1 []domain.Expense, err error)
	inspectFuncGetExpenses   func(ctx context.Context, userID int64)
	afterGetExpensesCounter  uint64
	beforeGetExpensesCounter uint64
	GetExpensesMock          mExpenseDBMockGetExpenses
}

// NewExpenseDBMock returns a mock for ExpenseDB
func NewExpenseDBMock(t minimock.Tester) *ExpenseDBMock {
	m := &ExpenseDBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddExpenseMock = mExpenseDBMockAddExpense{mock: m}
	m.AddExpenseMock.callArgs = []*ExpenseDBMockAddExpenseParams{}

	m.GetExpensesMock = mExpenseDBMockGetExpenses{mock: m}
	m.GetExpensesMock.callArgs = []*ExpenseDBMockGetExpensesParams{}

	return m
}

type mExpenseDBMockAddExpense struct {
	mock               *ExpenseDBMock
	defaultExpectation *ExpenseDBMockAddExpenseExpectation
	expectations       []*ExpenseDBMockAddExpenseExpectation

	callArgs []*ExpenseDBMockAddExpenseParams
	mutex    sync.RWMutex
}

// ExpenseDBMockAddExpenseExpectation specifies expectation struct of the ExpenseDB.AddExpense
type ExpenseDBMockAddExpenseExpectation struct {
	mock    *ExpenseDBMock
	params  *ExpenseDBMockAddExpenseParams
	results *ExpenseDBMockAddExpenseResults
	Counter uint64
}

// ExpenseDBMockAddExpenseParams contains parameters of the ExpenseDB.AddExpense
type ExpenseDBMockAddExpenseParams struct {
	ctx     context.Context
	userID  int64
	kopecks int64
	title   string
	date    time.Time
}

// ExpenseDBMockAddExpenseResults contains results of the ExpenseDB.AddExpense
type ExpenseDBMockAddExpenseResults struct {
	err error
}

// Expect sets up expected params for ExpenseDB.AddExpense
func (mmAddExpense *mExpenseDBMockAddExpense) Expect(ctx context.Context, userID int64, kopecks int64, title string, date time.Time) *mExpenseDBMockAddExpense {
	if mmAddExpense.mock.funcAddExpense != nil {
		mmAddExpense.mock.t.Fatalf("ExpenseDBMock.AddExpense mock is already set by Set")
	}

	if mmAddExpense.defaultExpectation == nil {
		mmAddExpense.defaultExpectation = &ExpenseDBMockAddExpenseExpectation{}
	}

	mmAddExpense.defaultExpectation.params = &ExpenseDBMockAddExpenseParams{ctx, userID, kopecks, title, date}
	for _, e := range mmAddExpense.expectations {
		if minimock.Equal(e.params, mmAddExpense.defaultExpectation.params) {
			mmAddExpense.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddExpense.defaultExpectation.params)
		}
	}

	return mmAddExpense
}

// Inspect accepts an inspector function that has same arguments as the ExpenseDB.AddExpense
func (mmAddExpense *mExpenseDBMockAddExpense) Inspect(f func(ctx context.Context, userID int64, kopecks int64, title string, date time.Time)) *mExpenseDBMockAddExpense {
	if mmAddExpense.mock.inspectFuncAddExpense != nil {
		mmAddExpense.mock.t.Fatalf("Inspect function is already set for ExpenseDBMock.AddExpense")
	}

	mmAddExpense.mock.inspectFuncAddExpense = f

	return mmAddExpense
}

// Return sets up results that will be returned by ExpenseDB.AddExpense
func (mmAddExpense *mExpenseDBMockAddExpense) Return(err error) *ExpenseDBMock {
	if mmAddExpense.mock.funcAddExpense != nil {
		mmAddExpense.mock.t.Fatalf("ExpenseDBMock.AddExpense mock is already set by Set")
	}

	if mmAddExpense.defaultExpectation == nil {
		mmAddExpense.defaultExpectation = &ExpenseDBMockAddExpenseExpectation{mock: mmAddExpense.mock}
	}
	mmAddExpense.defaultExpectation.results = &ExpenseDBMockAddExpenseResults{err}
	return mmAddExpense.mock
}

//Set uses given function f to mock the ExpenseDB.AddExpense method
func (mmAddExpense *mExpenseDBMockAddExpense) Set(f func(ctx context.Context, userID int64, kopecks int64, title string, date time.Time) (err error)) *ExpenseDBMock {
	if mmAddExpense.defaultExpectation != nil {
		mmAddExpense.mock.t.Fatalf("Default expectation is already set for the ExpenseDB.AddExpense method")
	}

	if len(mmAddExpense.expectations) > 0 {
		mmAddExpense.mock.t.Fatalf("Some expectations are already set for the ExpenseDB.AddExpense method")
	}

	mmAddExpense.mock.funcAddExpense = f
	return mmAddExpense.mock
}

// When sets expectation for the ExpenseDB.AddExpense which will trigger the result defined by the following
// Then helper
func (mmAddExpense *mExpenseDBMockAddExpense) When(ctx context.Context, userID int64, kopecks int64, title string, date time.Time) *ExpenseDBMockAddExpenseExpectation {
	if mmAddExpense.mock.funcAddExpense != nil {
		mmAddExpense.mock.t.Fatalf("ExpenseDBMock.AddExpense mock is already set by Set")
	}

	expectation := &ExpenseDBMockAddExpenseExpectation{
		mock:   mmAddExpense.mock,
		params: &ExpenseDBMockAddExpenseParams{ctx, userID, kopecks, title, date},
	}
	mmAddExpense.expectations = append(mmAddExpense.expectations, expectation)
	return expectation
}

// Then sets up ExpenseDB.AddExpense return parameters for the expectation previously defined by the When method
func (e *ExpenseDBMockAddExpenseExpectation) Then(err error) *ExpenseDBMock {
	e.results = &ExpenseDBMockAddExpenseResults{err}
	return e.mock
}

// AddExpense implements ExpenseDB
func (mmAddExpense *ExpenseDBMock) AddExpense(ctx context.Context, userID int64, kopecks int64, title string, date time.Time) (err error) {
	mm_atomic.AddUint64(&mmAddExpense.beforeAddExpenseCounter, 1)
	defer mm_atomic.AddUint64(&mmAddExpense.afterAddExpenseCounter, 1)

	if mmAddExpense.inspectFuncAddExpense != nil {
		mmAddExpense.inspectFuncAddExpense(ctx, userID, kopecks, title, date)
	}

	mm_params := &ExpenseDBMockAddExpenseParams{ctx, userID, kopecks, title, date}

	// Record call args
	mmAddExpense.AddExpenseMock.mutex.Lock()
	mmAddExpense.AddExpenseMock.callArgs = append(mmAddExpense.AddExpenseMock.callArgs, mm_params)
	mmAddExpense.AddExpenseMock.mutex.Unlock()

	for _, e := range mmAddExpense.AddExpenseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddExpense.AddExpenseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddExpense.AddExpenseMock.defaultExpectation.Counter, 1)
		mm_want := mmAddExpense.AddExpenseMock.defaultExpectation.params
		mm_got := ExpenseDBMockAddExpenseParams{ctx, userID, kopecks, title, date}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddExpense.t.Errorf("ExpenseDBMock.AddExpense got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddExpense.AddExpenseMock.defaultExpectation.results
		if mm_results == nil {
			mmAddExpense.t.Fatal("No results are set for the ExpenseDBMock.AddExpense")
		}
		return (*mm_results).err
	}
	if mmAddExpense.funcAddExpense != nil {
		return mmAddExpense.funcAddExpense(ctx, userID, kopecks, title, date)
	}
	mmAddExpense.t.Fatalf("Unexpected call to ExpenseDBMock.AddExpense. %v %v %v %v %v", ctx, userID, kopecks, title, date)
	return
}

// AddExpenseAfterCounter returns a count of finished ExpenseDBMock.AddExpense invocations
func (mmAddExpense *ExpenseDBMock) AddExpenseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddExpense.afterAddExpenseCounter)
}

// AddExpenseBeforeCounter returns a count of ExpenseDBMock.AddExpense invocations
func (mmAddExpense *ExpenseDBMock) AddExpenseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddExpense.beforeAddExpenseCounter)
}

// Calls returns a list of arguments used in each call to ExpenseDBMock.AddExpense.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddExpense *mExpenseDBMockAddExpense) Calls() []*ExpenseDBMockAddExpenseParams {
	mmAddExpense.mutex.RLock()

	argCopy := make([]*ExpenseDBMockAddExpenseParams, len(mmAddExpense.callArgs))
	copy(argCopy, mmAddExpense.callArgs)

	mmAddExpense.mutex.RUnlock()

	return argCopy
}

// MinimockAddExpenseDone returns true if the count of the AddExpense invocations corresponds
// the number of defined expectations
func (m *ExpenseDBMock) MinimockAddExpenseDone() bool {
	for _, e := range m.AddExpenseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddExpenseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddExpenseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddExpense != nil && mm_atomic.LoadUint64(&m.afterAddExpenseCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddExpenseInspect logs each unmet expectation
func (m *ExpenseDBMock) MinimockAddExpenseInspect() {
	for _, e := range m.AddExpenseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExpenseDBMock.AddExpense with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddExpenseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddExpenseCounter) < 1 {
		if m.AddExpenseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExpenseDBMock.AddExpense")
		} else {
			m.t.Errorf("Expected call to ExpenseDBMock.AddExpense with params: %#v", *m.AddExpenseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddExpense != nil && mm_atomic.LoadUint64(&m.afterAddExpenseCounter) < 1 {
		m.t.Error("Expected call to ExpenseDBMock.AddExpense")
	}
}

type mExpenseDBMockGetExpenses struct {
	mock               *ExpenseDBMock
	defaultExpectation *ExpenseDBMockGetExpensesExpectation
	expectations       []*ExpenseDBMockGetExpensesExpectation

	callArgs []*ExpenseDBMockGetExpensesParams
	mutex    sync.RWMutex
}

// ExpenseDBMockGetExpensesExpectation specifies expectation struct of the ExpenseDB.GetExpenses
type ExpenseDBMockGetExpensesExpectation struct {
	mock    *ExpenseDBMock
	params  *ExpenseDBMockGetExpensesParams
	results *ExpenseDBMockGetExpensesResults
	Counter uint64
}

// ExpenseDBMockGetExpensesParams contains parameters of the ExpenseDB.GetExpenses
type ExpenseDBMockGetExpensesParams struct {
	ctx    context.Context
	userID int64
}

// ExpenseDBMockGetExpensesResults contains results of the ExpenseDB.GetExpenses
type ExpenseDBMockGetExpensesResults struct {
	ea1 []domain.Expense
	err error
}

// Expect sets up expected params for ExpenseDB.GetExpenses
func (mmGetExpenses *mExpenseDBMockGetExpenses) Expect(ctx context.Context, userID int64) *mExpenseDBMockGetExpenses {
	if mmGetExpenses.mock.funcGetExpenses != nil {
		mmGetExpenses.mock.t.Fatalf("ExpenseDBMock.GetExpenses mock is already set by Set")
	}

	if mmGetExpenses.defaultExpectation == nil {
		mmGetExpenses.defaultExpectation = &ExpenseDBMockGetExpensesExpectation{}
	}

	mmGetExpenses.defaultExpectation.params = &ExpenseDBMockGetExpensesParams{ctx, userID}
	for _, e := range mmGetExpenses.expectations {
		if minimock.Equal(e.params, mmGetExpenses.defaultExpectation.params) {
			mmGetExpenses.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetExpenses.defaultExpectation.params)
		}
	}

	return mmGetExpenses
}

// Inspect accepts an inspector function that has same arguments as the ExpenseDB.GetExpenses
func (mmGetExpenses *mExpenseDBMockGetExpenses) Inspect(f func(ctx context.Context, userID int64)) *mExpenseDBMockGetExpenses {
	if mmGetExpenses.mock.inspectFuncGetExpenses != nil {
		mmGetExpenses.mock.t.Fatalf("Inspect function is already set for ExpenseDBMock.GetExpenses")
	}

	mmGetExpenses.mock.inspectFuncGetExpenses = f

	return mmGetExpenses
}

// Return sets up results that will be returned by ExpenseDB.GetExpenses
func (mmGetExpenses *mExpenseDBMockGetExpenses) Return(ea1 []domain.Expense, err error) *ExpenseDBMock {
	if mmGetExpenses.mock.funcGetExpenses != nil {
		mmGetExpenses.mock.t.Fatalf("ExpenseDBMock.GetExpenses mock is already set by Set")
	}

	if mmGetExpenses.defaultExpectation == nil {
		mmGetExpenses.defaultExpectation = &ExpenseDBMockGetExpensesExpectation{mock: mmGetExpenses.mock}
	}
	mmGetExpenses.defaultExpectation.results = &ExpenseDBMockGetExpensesResults{ea1, err}
	return mmGetExpenses.mock
}

//Set uses given function f to mock the ExpenseDB.GetExpenses method
func (mmGetExpenses *mExpenseDBMockGetExpenses) Set(f func(ctx context.Context, userID int64) (ea1 []domain.Expense, err error)) *ExpenseDBMock {
	if mmGetExpenses.defaultExpectation != nil {
		mmGetExpenses.mock.t.Fatalf("Default expectation is already set for the ExpenseDB.GetExpenses method")
	}

	if len(mmGetExpenses.expectations) > 0 {
		mmGetExpenses.mock.t.Fatalf("Some expectations are already set for the ExpenseDB.GetExpenses method")
	}

	mmGetExpenses.mock.funcGetExpenses = f
	return mmGetExpenses.mock
}

// When sets expectation for the ExpenseDB.GetExpenses which will trigger the result defined by the following
// Then helper
func (mmGetExpenses *mExpenseDBMockGetExpenses) When(ctx context.Context, userID int64) *ExpenseDBMockGetExpensesExpectation {
	if mmGetExpenses.mock.funcGetExpenses != nil {
		mmGetExpenses.mock.t.Fatalf("ExpenseDBMock.GetExpenses mock is already set by Set")
	}

	expectation := &ExpenseDBMockGetExpensesExpectation{
		mock:   mmGetExpenses.mock,
		params: &ExpenseDBMockGetExpensesParams{ctx, userID},
	}
	mmGetExpenses.expectations = append(mmGetExpenses.expectations, expectation)
	return expectation
}

// Then sets up ExpenseDB.GetExpenses return parameters for the expectation previously defined by the When method
func (e *ExpenseDBMockGetExpensesExpectation) Then(ea1 []domain.Expense, err error) *ExpenseDBMock {
	e.results = &ExpenseDBMockGetExpensesResults{ea1, err}
	return e.mock
}

// GetExpenses implements ExpenseDB
func (mmGetExpenses *ExpenseDBMock) GetExpenses(ctx context.Context, userID int64) (ea1 []domain.Expense, err error) {
	mm_atomic.AddUint64(&mmGetExpenses.beforeGetExpensesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExpenses.afterGetExpensesCounter, 1)

	if mmGetExpenses.inspectFuncGetExpenses != nil {
		mmGetExpenses.inspectFuncGetExpenses(ctx, userID)
	}

	mm_params := &ExpenseDBMockGetExpensesParams{ctx, userID}

	// Record call args
	mmGetExpenses.GetExpensesMock.mutex.Lock()
	mmGetExpenses.GetExpensesMock.callArgs = append(mmGetExpenses.GetExpensesMock.callArgs, mm_params)
	mmGetExpenses.GetExpensesMock.mutex.Unlock()

	for _, e := range mmGetExpenses.GetExpensesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetExpenses.GetExpensesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExpenses.GetExpensesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetExpenses.GetExpensesMock.defaultExpectation.params
		mm_got := ExpenseDBMockGetExpensesParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetExpenses.t.Errorf("ExpenseDBMock.GetExpenses got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetExpenses.GetExpensesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetExpenses.t.Fatal("No results are set for the ExpenseDBMock.GetExpenses")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetExpenses.funcGetExpenses != nil {
		return mmGetExpenses.funcGetExpenses(ctx, userID)
	}
	mmGetExpenses.t.Fatalf("Unexpected call to ExpenseDBMock.GetExpenses. %v %v", ctx, userID)
	return
}

// GetExpensesAfterCounter returns a count of finished ExpenseDBMock.GetExpenses invocations
func (mmGetExpenses *ExpenseDBMock) GetExpensesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExpenses.afterGetExpensesCounter)
}

// GetExpensesBeforeCounter returns a count of ExpenseDBMock.GetExpenses invocations
func (mmGetExpenses *ExpenseDBMock) GetExpensesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExpenses.beforeGetExpensesCounter)
}

// Calls returns a list of arguments used in each call to ExpenseDBMock.GetExpenses.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetExpenses *mExpenseDBMockGetExpenses) Calls() []*ExpenseDBMockGetExpensesParams {
	mmGetExpenses.mutex.RLock()

	argCopy := make([]*ExpenseDBMockGetExpensesParams, len(mmGetExpenses.callArgs))
	copy(argCopy, mmGetExpenses.callArgs)

	mmGetExpenses.mutex.RUnlock()

	return argCopy
}

// MinimockGetExpensesDone returns true if the count of the GetExpenses invocations corresponds
// the number of defined expectations
func (m *ExpenseDBMock) MinimockGetExpensesDone() bool {
	for _, e := range m.GetExpensesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExpensesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExpensesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExpenses != nil && mm_atomic.LoadUint64(&m.afterGetExpensesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetExpensesInspect logs each unmet expectation
func (m *ExpenseDBMock) MinimockGetExpensesInspect() {
	for _, e := range m.GetExpensesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExpenseDBMock.GetExpenses with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExpensesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExpensesCounter) < 1 {
		if m.GetExpensesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExpenseDBMock.GetExpenses")
		} else {
			m.t.Errorf("Expected call to ExpenseDBMock.GetExpenses with params: %#v", *m.GetExpensesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExpenses != nil && mm_atomic.LoadUint64(&m.afterGetExpensesCounter) < 1 {
		m.t.Error("Expected call to ExpenseDBMock.GetExpenses")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExpenseDBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddExpenseInspect()

		m.MinimockGetExpensesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExpenseDBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExpenseDBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddExpenseDone() &&
		m.MinimockGetExpensesDone()
}
